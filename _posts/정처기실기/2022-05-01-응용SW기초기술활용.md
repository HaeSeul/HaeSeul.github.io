---
layout: single
title: "[정처기] 운영체제"
categories: 
    - EIP
tags: 
    - [정처기, 정처기실기]
toc: true
toc_sticky: true
---

 > 📌 참고
 > 시분할시스템 (Time Sharing)
 > 실시간처리 (Real-Time)
 > 일괄처리 (Batch)
 > 분산처리 (Distributed)

# 📂 운영체제 종류

- 운영체제 (Operating System)
 : 컴퓨터 하드웨어를 쉽게 사용할 수 있도록 인터페이스 제공하는 소프트웨어
    - 특징
      - 사용자 편기성 제공
      - 인터페이스 기능 (사용자와 컴퓨터 시스템 연결)
      - 스케줄링 (다중환경 → 자원의 현재 상태 파악 + 자원 분배 스케줄링)
      - 자원 관리
      - 제어 기능 (입출력장치, 사용자 프로그램)
    - 구조
      - 쉘 (Shell) : 인터페이스, 사용자 명령 처리(명령어 해석기)
      - 커널 (Kernel) : 기능 집합, 하드웨어 관련 내부 역할
        - 프로세스 관리, 스케줄링, 동기화
        - 기억장치 관리 (메모리 할당, 회수)
        - 주변장치 관리 (입출력 장치 스케줄링)
        - 파일 관리

## 📝 윈도즈 운영체제
 : MS-DOS의 멀티태스킹, GUI환경 제공하는 MS 운영체제

- 특징 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>지선자 오</span></b>
  - GUI 제공
  - 선점형 멀티태스킹 방식 제공 (동시에 여러 프로그램 실행 → OS가 CPU 이용시간 제어)
  - 자동감지 기능 (하드웨어 설치 → 필요한 시스템 환경 자동 구성)
  - OLE (문서에 개체 연결, 삽입)

<br>

## 📝 유닉스 계열 운영체제
 : 범용 다중 사용자 방식의 시분할 운영체제

- 특징 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>대다 사이계</span></b>
  - 대화식 운영체제 : 프롬프트에 명령 입력 → CLI 방식
  - 다중 작업 기능 : 여러 프로세스 → 공용자원(CPU) 나눠서 사용
  - 다중 사용자 기능 : 여러 단말(키보드, 모니터) → 한 컴퓨터에 연결 → 여려명 동시 작업
  - 이식성 : 90% 이상 C 언어 + 시스템 프로그램 모듈화 → 다른 하드웨어로 이식 쉬움
  - 계층적 트리 구조 파일 시스템 : 통합적 파일 관리 가능
- 리눅스 운영체제 : 유닉스 기반 오픈 소스 운영체제
- 맥 운영체제 : 애플의 매킨토시용 유닉스 기반 GUI 운영체제
- 안드로이드 운영체제 : 리눅스 기반 자바/코틀린 언어 사용, 런타임 라이브러리, 안드로이드 SDK 제공

<br><br>

# 📂 운영체제 기본 명령어

## 📝 윈도즈 운영체제 기본 명령어
 : 명령창에서 CLI로 입력 가능 (기본은 GUI)

- Help : 검색
- ATTRIB : 파일 속성 표시/수정
- CALL : 다른 프로그램 호출
- **CD** : 현재 디렉터리 이름 표시/수정
- CHKDSK : 디스크 검사
- CLS : 화면 지움
- CMD : 윈도즈 명령 프롬프트 창 열기
- COMP : 여러 파일 비교
- DISKPART : 디스크 파티션 속성 표시/구성
- ECHO : 메시지 표시/ECHO 사용
- ERASE : 파일 지움
- EXIT : CMD.EXE 마침

<br>

## 📝 리눅스/유닉스 계열 기본 명령어
 : 쉘에서 입력 (# : 최상위유저, $ : 일반유저)

- --help, -h : 명령어 도움말
- 시스템 관련
  - **uname -a** : 시스템 모든 정보 확인
  - uname -r : 운영체제 배포버전
  - cat : 파일 내용 출력
  - uptime : 시스템 가동시간, 현재 사용자 수, 평균 부하량
- 사용자
  - id
  - **last** : 모든 사용자의 로그인/로그아웃 정보
  - who : 현재 접속자 정보
- 파일처리
  - **ls** : 현재 폴더의 파일/폴더 표시
  - **pwd** (print working directory) : 현재 디렉토리 절대 경로 출력
  - **rm** : 파일 삭제
  - **cp** : 파일 복사
  - **mv** : 파일 이동
- 프로세스
  - ps : 실행되고 있는 프로세스 목록
  - pmap : 프로세스 ID 기준 메모리 맵 정보 출력
  - kill : 특정 PID 프로세스 종료
- 파일 권한
  - **chmod** : 특정 파일/디렉토리 퍼미션 수정
  - **chown** : 파일/디렉토리 소유자/그룹 수정
- 네트워크
  - ipconfig : 네트워크 인터페이스 설정/확인
  - host : 도메인(호스트)랑 ip 주소 중 하나만 알 때
- 압축
  - tar : 여러 파일 하나로 묶거나 풀 때 (압축은 X)
  - gzip : 압축 (파일 묶거나 풀기는 X)
- 검색
  - grep : 입력된 파일에서 특정 문자열 찾기
  - find : 특정 파일 찾기
- 파일이동
  - cp : 디렉토리 복사
  - rsync : 로컬/원격 파일과 디렉토리 복사/동기화
- 디스크 사용
  - df : 시스템에 마운트된 하드디스크 남은 용량 확인
  - du : 파일 사이즈를 kb 단위로 표시
- 디렉토리 이동
  - **cd** : 디렉토리 이동

### 📌 유닉스 파일 접근 권한 관리

- 파일 접근제어 개요
  - 파일 읽거나 실행 → open(), read(), write() 시스템 호출 → 파일 정보 저장돤 i-node 값 읽음
    - i-node : 파일 정보 + 접근제어 정보 수록 (DAC 기반 접근제어)
- 파일 접근제어 메커니즘
  - 접근 권한 유형 (설정 명령어 : chown, chgrp)
    - User : 파일 사용하는 사용자 (owner)
    - Group : 소유자 제외, 파일과 같은 그룹에 속한 모든 사용자
    - Other : 그 밖의 사용자
  - 파일 접근 모드 (설정 명령어 : chmod)
    - R (Read) : 4
    - W (Write) : 2
    - X (eXecute) : 1
  - 접근 권한 변경 (chmod) : 파일 소유자나 슈퍼 유저 root만 실행가능
    - 대상 : u(user), g(group), o(other), a(all)
    - 연산자 : +(추가), -(제거), =(지정)
    - 접근권한 : r/4(read), w/2(write), x/1(execute)
      - chmod go-w yoom.c : yoom.c에 group, other의 write 권한 제거
      - chmod a=rw yoom.c : yoom.c에 all의 read, write 권한 지정
      - chmod g+w, o-x yoom.c : yoom.c에 group의 write 권한 추가, other의 execute 권한 제거
      - chmod 777 yoom.c : 모든 사용자에게 rwx 권한 설정
      - chmod 664 yoom.c : user, group에게 rw 권한, others에게 r 권한
      - chmod 600 yoom.c : user에게 rw 권한

<br><br>

# 📂 운영체제 핵심 기능

## 📝 메모리 관리

- 프로그램 실행 종료까지 메모리를 가용한 상태로 유지/관리
- 가상 주소 부여 → 메모리 관리 장치(MMU) → 물리 주소로 변환

<br>

### 📌 메모리 관리 기법 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>반배할교</span></b>

1. <b><span style='color:#006DD7'>반입 기법</span></b> : 메모리 적재 시기 결정 (When)
   1. 요구 반입 기법 : 다름 프로세스 참조 요구가 있을 때
   2. 예상 반입 기법 : 요구 예측 → 미리 메모리에 적재
2. <b><span style='color:#006DD7'>배치 기법</span></b> : 메모리 적제 위치 결정 (Where)
   1. 최초 적합 (First Fit) : 가용 공간 중 첫 번째 분할에 할당
   2. 최적 적합 (Best Fit) : 가용 공간 중 크기가 비슷한 공간에 할당 (공백 최소화)
   3. 최악 적합 (Worst Fit) : 가용 공간 중 가장 큰 공간에 할당
3. <b><span style='color:#006DD7'>할당 기법</span></b> : 메모리 적재 방법 결정 (How) ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>연단다 분페세</span></b>
   1. 연속 할당 기법 : <u>주기억장치</u> 내 인접하게 할당
        - 단일 분할 할당 기법 : 오버레이, 스와핑
        - 다중 분할 할당 기법 : 고정/동적 분할 할당 기법
   2. 분산 할당 기법 : 한 프로세스를 조각내 <u>가상기억장치</u>에 분산 배치
        - 페이징 기법
          - 가상기억장치 프로세스 → 일정 블록으로 분할 → 주기억장치 분산 공간에 적재
          - 실제 공간 : 페이지 크기와 같은 페이지 프레임(블록)으로 나누어 사용
          - 논리주소 = 페이지번호(p) + 변위(d)
          - 물리주소 = 실제 메모리 기준 주소 + d
          - 장점 : 공유 페이지 사용, 메모리 활용 → 다중 처리 프로그래밍
          - 단점 : 페이징 사상 하드웨어 비용, 속도 저하, <u>내부단편화</u> 현상
          - 페이지 크기 작을 경우
              - 페이지 사상 테이블 공간 ↑ but 내부단편화 ↓ 기억장치효율 ↑
              - 페이지 맵 테이블 크기 ↑ 매핑속도 ↓ 디스크 접근 횟수 ↑ 입출력시간 ↑
          - 페이지 크기 클 경우
              - 테이블 크기 ↓ 주기억장치 공간절약 but 페이지 단편화 ↑ 기억공간 낭비 ↑
              - 페이지 맵 테이블 크기 ↓ 매핑속도 ↑ 디스크 접근 횟수 ↓ 입출력시간 ↓
        - 세그먼테이션 기법
          - 가상기억장치 프로세스 → 가변 크기 블록(배열, 함수)으로 분할 → 메모리 할당
          - 세그먼트 테이블 = 메모리 시작주소(base) + 세그먼트 크기(limit) ⇒ 세그먼트 테이블은 메인 메모리에
          - 논리주소 = 세그먼트 번호(s) + 변위(d)
          - 물리주소 = base[s] + d ⇒ 해당 세그먼트 크기 넘어서면 프로세스 강제 종료
          - 장점 : 가변적 구조 처리, 자원의 효율적 이용
          - 단점 : <u>외부단편화</u>
        - 페이징/세그먼테이션 기법
          - 한 세그먼트 → 정수 배 부분 페이지로 분할
4. <b><span style='color:#006DD7'>교체 기법</span></b> : 메모리 교체 대상 결정 (Who)
   1. FIFO : 선입선출
   2. LRU (Least Recently Used)
   3. LFU (Least Frequently Used)
   4. OPT (Optimal Replacement) : 앞으로 사용하지 않을 페이지
   5. NUR (Not Used Recently) : 최근 사용여부 확인 → 페이지마다 참조비트, 변형비트 사용 → LRU의 오버헤드 감소
   6. SCR (Second Chance Replacement) : 오래 있어도 자주 사용되면 교체 X → FIFO 단점 보완

<br>

### 📌 메모리 단편화
 : 사용되지 못하고 낭비되는 기억장치

- 내부 단편화 : 프로세스 적재 후 남은 공간
  - 발생 : 고정 분할 할당, 페이징 기법
  - 방안 : Slab Allocator (작은 크기로 분할, 할당 → 동적 메모리 관리 기법), 통합, 압축
- 외부 단편화 : 할당된 크기가 작아서 사용하지 못하는 공간
  - 발생 : 동적 분할 할당, 세그먼테이션
  - 방안 : 버디 메모리 할당 (2n 크기로 할당 → 요청한 크기에 알맞게 할당 가능), 통합, 압축

<br>

### 📌 페이징 기법의 문제 및 해결방안

- 문제점 : 스레싱 (Thrashing)
  - 개념 : 프로세스 실제 처리 시간 < 페이지 교체 시간
  - 특징 : 페이지부재 ↑ 오류율 ↑ 스레싱 ↑  ⇒  전체 성능, 처리율 ↓ 기억장치 접근시간 ↑
- 해결방안
  - 워킹 세트 (Working Set) : 각 프로세스가 많이 참조하는 페이지 집합에 계속 상주
    - 장점 : 멀티 프로그래밍, Page Hit 증가, CPU 활용률 최적화
    - 단점 : 추적관리 복잡, 워킹 세트 크기 설정이 모호
  - 페이지 부재 빈도 (PFF) : 페이지 부재율 상한/하한 정해서 페이지 부재율 예측/조절
    - 장점 : 부하 적음, 직접 페이지 부재율 조절 가능
    - 단점 : 프로세스 중지 과정 발생, 페이지 참조가 새 지역성으로 이동 가능

<br>

### 📌 지역성 (Locality)
 : 스레싱 방지를 위한 워킹 셋 이론의 기반
- 시간 지역성 (Temporal)
 : 최근 사용된 곳에 집중 (참조했던 곳은 빠른 시간 내 다시 참조할 가능성 높음)
  - 사례 : **Loop, Stack, Sub Routine**, Counting, 집계변수
- 공간 지역성 (Spatial)
 : 일정 위치 페이지 집중 (참조된 메모리 근처 메모리 참조)
  - 사례 : 열순회, 변수 선언/참조
- 순차 지역성 (Sequential)
 : 데이터 순차적 액세스 (공간 지역성 일부)
  - 사례 : 순차적 코드 실행

<br>

## 📝 프로세스 관리

- 프로세스 제어 블록 (PCB) : 프로세스 관리를 위한 운영체제의 자료구조
- 문맥교환 : PCB에 현재 프로세스 저장 → 다음 프로세스의 PCB로부터 문맥 복원

### 📌 프로세스 상태 및 전이

- 프로세스 상태
  1. 생성 (Create)
  2. 준비 (Ready)
  3. 실행 (Running)
  4. 대기 (Waiting)
  5. 완료 (Complete)
- 프로세스 전이
  1. 준비 → 실행 프로세스 선정(Scheduling) → CPU 할당 (**Dispatching**) → 문맥교환 → 실행
  2. 실행 → Time Slice만료 or 선점 (Preemption) → 할당 시간 초과 (**Timer run out**) → CPU 반납 → 준비
  3. 실행 → 입출력발생(**Block**) → CPU 반납 → 대기
  4. 대기 → 입출력 종료 → 깨움 (**Wake-up**) → 준비

<br>

### 📌 스레드 (Thread)
 : 프로세스에서 <u>실행제어</u>만 분리한 순차적 제어 흐름 실행단위

- 프로세스보다 가벼운, 독립적 수행
- 한 프로세스에 여러 스레드 (다중 프로그래밍 시스템에서 CPU 받아 수행)
- 종류 
  - 사용자 수준의 스레드 : 사용자가 만든 라이브러리, 빠르지만 구현이 어려움
  - 커널 수준의 스레드 : 운영체제 커널이 운용, 구현 쉽지만 느림

<br>

### 📌 프로세스 스케줄링
 : CPU 사용하려는 프로세스 간 우선순위 관리

- 용어
  - 서비스시간 : 실행시간
  - 응답시간 (Response Time) : 입력 ~ 요청 ~ 반응까지
  - 반환시간 (Turnaround Time) : 입력 ~ 수행 ~ 결과 산출까지
   = 대기시간 + 수행시간 = 종료시간 - 도착시간
  - 대기시간 : 프로세서 할당 전까지 큐에 대기하는 시간
   = 반환시간 - 실행시간 = 종료시간 - 도착시간 - 실행시간
  - 평균 대기시간 : 대기시간 0도 합산
  - 종료시간
  - 시간 할당량 (Time Slice, Time Quantum) : 프로세서 독점 방지 위해 서비스 시간 할당
  - 응답률 : HRN(Highest Response ratio Next) 스케줄링에서 응답률 높으면 우선순위 높음
   = (대기시간 + 서비스시간) / 서비스시간

- <b><span style='color:#006DD7'>선점형 스케줄링 </span></b>(Preemptive Scheduling)
 : 우선순위 높은 프로세스가 CPU 점유
  - 장점 : 비교적 빠른 응답, 대화식 시분할 시스템(Time Sharing)
  - 단점 : 높은 우선순위 프로세스가 들어오면 오버헤드
  - 활용 : 실시간 응답환경, Deadline 응답환경
  - 알고리즘 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>SMMR</span></b>
    - <b><span style='color:#EF6F53'>SRT</span></b> (Shortest Remaining Time First)
      - 시분할 시스템에 유용
      - SJF보다 평균 대기시간, 반환시간 짧음
    - <b><span style='color:#EF6F53'>MLQ</span></b> (Multi-Level Queue)
      - 작업 → 여러 그룹으로 분할 → 여러 큐 사용 → 상위 단계 작업이 하위 단계 작업 선점
      - 각각 독립된 스케줄링 큐
    - <b><span style='color:#EF6F53'>MLFQ</span></b> (Multi-Level Feedback Queue) = FCFS + Round Robin
      - 큐마다 다른 시간 할당량
      - 우선순위 : 새 프로세스 > 실행시간 길 수록 낮은 우선순위 → 마지막 단계는 라운드 로빈
    - Round Robin
      - 같은 크기의 CPU 시간 할당(Time Slice) → 시간 내 완료 못하면 준비 큐 가장 뒤로 ⇒ 시분할 시스템

- <b><span style='color:#006DD7'>비선점형 스케줄링 </span></b>(Non Preemptive Scheduling)
 : CPU 반환 시까지 다른 프로세스의 점유 X
  - 장점 : 응답시간 예상 가능, 모든 프로세스 공정 처리
  - 단점 : 짧은 작업 프로세스의 무한 대기
  - 활용 : 처리시간 편차가 적은 환경
  - 알고리즘 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>우기 FHS</span></b>
    - Priority
      - 주요 프로세스 우선, 동일 순위는 FCFS
    - Deadline
      - 명시된 시간 내 처리
    - FCFS (First Come First Served)
    - HRN (High Response Ratio Next)
      - 우선순위 : 대기시간 긴 프로세스 → 응답률 고려
      - 기아현상 최소화 = aging 기법 (SJF 단점 보완)
    - SJF (Shortest Job First)
      - 우선순위 : 그 당시 서비스 시간 가장 짧은 것 → 평균 대기시간 최소 but <u>기아현상</u> 발생 가능
      - 일괄처리 환경에 유용
      - SRT에 비해 평균 대기시간이 김

### 📌 교착상태 (Deadlock)
 : 여러 프로세스 → 자원할당을 무한정 대기하는 상태

- 발생 조건 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>상점비환</span></b>
  - 상호배제 (Mutual Exclusive)
   : 프로세스가 자원을 배타적으로 점유 → 다른 프로세스가 사용 X
  - 점유와 대기 (Hold & Wait)
   : 한 프로세스가 자원 점유 중 + 또다른 자원 요청해서 대기중
  - 비선점 (Non Preemption)
   : 이미 점유된 자원은 다른 프로세스가 점유 불가, 점유 프로세스의 해제만 가능한 상태
  - 환형 대기 (Circular Wait)
   : 프로세스 간 자원 점유와 대기가 원형 구성

- 해결 방법 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>예회발복</span></b>
  - 예방 (Prevention)
   : 상호배제 제외 나머지 교착상태 발생조건 부정 (점유자원 해재 후 새 자원 요청)
  - 회피 (Avoidance)
   : 안전 유지 가능한 요구만 수락 (<b><span style='color:#006DD7'>은행가 알고리즘</span></b>, Wound-Wait, Wait-Die)
  - 발견 (Detection)
   : 감시 알고리즘으로 교착상태 검사 (자원할당 그래프, Wait for Graph)
  - 복구 (Recovery)
   : 교착상태 없어질 때까지 순차적으로 프로세스 Kill → 희생자 선택, 기아 상태 발생 (프로세스 Kill, 자원선점)

<br><br>

# 📂 가상화, 클라우드

## 📝 가상화
 : 물리적 리소스를 사용자에게 하나로 or 한 물리적 리소스를 사용자에게 여러개로 보이게 함
- 종류
  - 플랫폼 가상화 : 하드웨어 플랫폼에서 실행되는 호스트 프로그램 → 게스트 프로그램 만들어 독립된 환경 만든 것 처럼 보여줌
  - 리소스 가상화 : 게스트 소프트웨어에서 사용할 때 독립된 하드웨어에서 실행되는 것처럼 활용
- 기술요소
  - 컴퓨팅 가상화 (서버 가상화)
    - 물리적으로 컴퓨터 리소스 가상화 → 논리적 단위로 리소스 활용
    - 서버 가상화로 <b><span style='color:#006DD7'>한 시스템에서 여러 운영체제</span></b> 동시 가동 → 서버 이용률 향상
    - ex) 하이퍼바이저 : 한 컴퓨터에서 여러 운영체제 구동하는 HW와 OS 사이의 SW 가상화 플랫폼
  - 스토리지 가상화
    - 스토리지와 서버 사이 SW/HW 계층 추가 → 스토리지 논리적 제어
    - <u>이기종 스토리지 시스템 통합</u>
    - ex) 분산 파일 시스템
  - I/O 가상화
    - 서버와 I/O 디바이스 사이의 <u>미들웨어</u> 계층
    - 서버의 I/O 자원을 물리적으로 분리, 케이블과 스위치 구성 단순화
    - ex) 가상 네트워크 인터페이스 카드
  - 컨테이너
    - 컨테이너화 된 앱이 <b><span style='color:#006DD7'>단일 운영체제에서 실행</span></b>되도록 해줌
    - 하이퍼바이저 없이 <b><span style='color:#006DD7'>운영체제가 격리된 프로세스에서 동작</span></b> → 오버헤드 낮음
    - ex) 도커 : 하이퍼바이저 없이 리눅스 컨테이너 기술을 앱이 격리된 상태에서 실행하는 가상화 솔루션
  - 분산처리 기술
    - 여러 대의 컴퓨터 계산, 저장능력을 이용해 큰 계산문제나 대용량 데이터 처리 및 저장
  - 네트워크 가상화 기술
    - <b><span style='color:#006DD7'>중계장치</span></b>(라우터, 스위치)의 가상화 → 가상 네트워크 지원
    - ex) SDN(Software Defined Network), NFV(Network Function Virtualization)

<br>

## 📝 클라우드 컴퓨팅
 : 인터넷을 통해 가상화된 컴퓨터 리소스 제공 + 정보를 클라우드에 연결된 다른 컴퓨터로 처리

- 분류
  - Private Cloud : 기업 내부에 구축, 직접 통제, 보안성향상
  - Public Cloud : 클라우드 제공업체에서 다중 사용자를 위한 컴퓨팅 자원 서비스 제공, 비용 지불, 확장성, 유연성
  - Hybrid Cloud : 사설 + 공용
- 유형 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>인플소</span></b>
  - <b><span style='color:#006DD7'>인프라형 서비스 (IaaS; Infrastructure as a Service)</span></b>
    - 시스템자원(서버, 스토리지)을 클라우드로 제공
    - 컴퓨팅 자원에 SW 탑재
    - 하위 클라우드 인프라를 제어하지는 않지만, 스토리지 및 앱은 제어함
  - <b><span style='color:#006DD7'>플랫폼형 서비스 (PaaS; Platform as a Service)</span></b>
    - 인프라 없이 앱 관리, SaaS를 개발 플랫폼으로 확장한 방식
    - 플랫폼 구축 없이 필요 개발 요소를 웹에서 빌려 쓸 수 있음
  - <b><span style='color:#006DD7'>소프트웨어형 서비스 (SaaS; Software as a Service)</span></b>
    - SW와 관련 데이터는 중앙호스팅, 사용자는 클라이언트(웹브라우저) 통해 접속
    - SW를 서비스 형태로 이용 (주문형 SW)