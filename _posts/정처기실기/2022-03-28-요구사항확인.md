---
layout: single
title: "[정처기] 요구사항 확인"

categories:
  -  EIP
tags:
  - [정처기, 정처기실기, 요구사항]

toc: true
toc_sticky: true
---

# 📂 소프트웨어 개발방법론

## 📝 소프트웨어 생명주기 모델 (SDLC)


### SDLC 프로세스 <b><span style='color:#2D3748; background-color:#fff5b1'>(분설구테유)</span></b>

   - 요구사항 분석 - 설계 - 구현 - 테스트 - 유지보수


### SDLC 모델종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(폭프나반)</span></b>

  - **폭포수 모델**
    - Boehm, <b><span style='color:#006DD7'>선형 순차적</span></b>, 고전적
    - 단계별 정의, 산출물 명확
    - 절차 : 타당성검토 → 계획 → 분설구테유
    - 장점 : 이해 굿, 관리 굿
    - 단점 : 요구사항 변경이 어려움
  - **프로토타입 모델**
    - 고객 <b><span style='color:#006DD7'>피드백</span></b> 반영한 주요 기능 → 프로토타입으로 구현
    - 공동의 참조 모델 제공 to 발주자 & 개발자
    - 절차 : 요구사항 분석 → 프로토타입 개발/<b><span style='color:#006DD7'>평가</span></b> → 구현 → 테스트
    - 장점 : 요구분석 굿, 타당성검증 가능
    - 단점 : 프로토타입 폐기 시 비용증가
  - **나선형 모델 (Spiral)**
    - 점진적개발 → 개발위험 최소화
    - 절차 : 계획/정의 → <b><span style='color:#006DD7'>위험분석</span></b> → 개발 → <b><span style='color:#006DD7'>고객평가</span></b> → 반복
    - 장점 : 위험성 감소, 변경 대처 굿
    - 단점 : 단계 반복에 따른 관리 어려움
  - **반복적 모델 (Iteration)**
    - 증분 방식, 병행 개발 → 통합 or 반복개발
    - 장점 : 병행 개발 → 일정 단축
    - 단점 : 병행 개발 → 관리비용 증가

<br>

## 📝 소프트웨어 개발방법론 종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(구정객컴애제)</span></b>

  - **구조적 방법론**
    - 분할 & 정복 : 전체시스템 → 기능별 개발 → <b><span style='color:#006DD7'>프로세스 중심의 정형화된 하향식 통합</span></b>
    - 나씨-슈나이더만 차트 : 구조적, 도형식 표현, 제어 논리 기술, 시각적 식별 가능
  - 정보공학 방법론
    - 데이터 중심 : 상호 연관성 있게 통합
  - 객체지향 방법론
  - **컴포넌트 기반 방법론 (CBD)**
    - 소프트웨어를 구성하는 컴포넌트를 조립해 새 응용 프로그램 작성
    - 재사용 굿, 생산성 굿, 품질 굿, 유지보수 비용 최소화, 복잡성 최소화(독립적인 컴포넌트 단위)
  - **애자일 방법론**
    - <b><span style='color:#EF6F53'>XP</span></b> (실용성강조)
      - 5 가치 <b><span style='color:#2D3748; background-color:#fff5b1'>(용단의피존)</span></b>
       : 용기, 단순성, 의사소통, 피드백, 존중
      - 12 기본원리
       : Pair programming, Collective ownership, Continuous integration, Planning process, Small release, Metaphor, Simple design, Test driven develop, Refactoring, 40-hour work, On-site customer, Coding standard
    - <b><span style='color:#EF6F53'>SCRUM</span></b> (프로젝트 관리 중심) : 매일 정해진 시간/장소에서 짧은 시간 개발
      - <b><span style='color:#006DD7'>Backlog</span></b> : 요구사항
      - <b><span style='color:#006DD7'>Sprint</span></b> : 2~4주 짧게 반복 개발
      - <b><span style='color:#006DD7'>Scrum Meeting</span></b> : 매일 15분 미팅
      - <b><span style='color:#006DD7'>Scrum Master</span></b> : 프로젝트 리더
      - <b><span style='color:#006DD7'>Sprint Retrospective</span></b> : 스프린트 주기 회고
      - <b><span style='color:#006DD7'>Burn Down Chart</span></b> : 남은 백로그 대비 시간을 차트로 표현
    - <b><span style='color:#EF6F53'>Lean</span></b> : JIT(Just In Time), 칸반(Kanban) 보드 사용
      - 7 원칙 <b><span style='color:#2D3748; background-color:#fff5b1'>(낭품지 확인사전)</span></b>
       : 낭비제거, 품질내재화, 지식창출, 늦은 확정, 빠른인도, 사람존중, 전체최적화
  - **제품 계열 방법론**
    - 특정 제품에 적용하고 싶은 <b><span style='color:#006DD7'>공통 기능을 정의</span></b>해서 개발
    - 임베디드 소프트웨어 작성에 유용

<br>

## 📝 비용산정모델 분류

### 하향식 : 전문가, 조정자를 통해 비용산정
  - 전문가 감정 기법 : 편리, 신속, 개인적, 주관적
  - 델파이 기법 : 여러 전문가 의견 종합 → 1명의 조정가
   
### 상향식 : 세부 요구사항/기능에 따라 비용산정
  - **LOC (Lines of Code)**
    - 원시 코드 라인 수의 낙관치, 중간치, 비관치 측정 → 예측치 → 비용산정
    - 예측치 : (낙관치 + 4*중간치 + 비관치) / 6
  - **Man Month**
    - MM = LOC / 프로그래머의 월간 생산성
    - 프로젝트 기간 = MM / 프로젝트 인력
  - **COCOMO** (COnstructive COst MOdel)
    - 보헴, 프로그램 규모에 따른 비용 산정
    1. <b><span style='color:#006DD7'>조직형, 단순형 (organic)</span></b> : 5만 라인 이하 소규모, 일괄 자료처리
    2. <b><span style='color:#006DD7'>반분리형, 중간형 (semi-detached)</span></b> : 30만 라인 이하 유틸개발(트랜잭션 처리, DB관리시스템, 컴파일러, 인터프리터 등)
    3. <b><span style='color:#006DD7'>임베디드형 (embedded)</span></b> : 30만 라인 이상 시스템 프로그램 개발(초대형 트랜잭션, 실시간 처리 시스템)
  - **푸트남 (Putnam) 모형**
    - <b><span style='color:#006DD7'>생명주기 예측모형</span></b> : 개발주기 단계별 요구할 인력 분포 가정
    - Rayleigh-Norden 곡선의 노력분포도 기초 (시간에 따른 함수)
    - 자동화 추정 도구 : <b><span style='color:#006DD7'>SLIM</span></b>
  - **FP (Function Point)**
    - 기능별 가중치 → 총 기능 점수 계산
    - 비용 산정 요소 : 자료입출력, 명령어, 데이터파일, 필요한 외부 루틴과의 인터페이스
    - 프로그래밍 언어에 독립적
    - 자동화 추정 도구 : <b><span style='color:#006DD7'>ESTIMACS</span></b>
  - 개발 단계별 노력 (Effort Per Task) 기법
    - LOC의 확장 : LOC을 SDLD 단계별 적용 → 모든 단계의 비용 산정

<br>

## 📝 일정관리모델 종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(주펄중)</span></b>

  - <b><span style='color:#006DD7'>CPM (Critical Path Method) : 주 공정법</span></b>
    - Critical Path (<b><span style='color:#006DD7'>임계경로</span></b>) : 가장 긴 경로
    - 여러 작업 수행순서 얽힌 프로젝트의 일정 계산
  - PERT (Program Evaluation and Review Technique)
    - 일 순서 정리하는 수렴기법
    - 비관치, 중간치, 낙관치의 3점 추정방식
  - CCPM (Critical Chain Project Management) : 중요 연쇄 프로젝트 관리
    - 주공정 연쇄법 → 자원 제약사항 고려해 일정 작성

<br><br>

# 📂 현행 시스템 분석


## 📝 소프트웨어 아키텍처 4+1 뷰 <b><span style='color:#2D3748; background-color:#fff5b1'>(유논프구배)</span></b>

고객 요구사항 정리한 시나리오 → 4개의 관점에서 바라봄
- **Usecase View** : 다른 뷰 검증에 사용 (사용자 입장에서 인식되는 시스템의 기능 요구사항에 초점)
- **Logical View** : 기능적 요구사항이 어떻게 제공되는지 설명
- **Process View** : 비기능적 속성 표현
- **Implementation View** : 정적인 소프트웨어 모듈 구성 (컴포넌트 구조)
- **Deployment View** : 컴포넌트가 어떻게 아키텍쳐에 배치되는지 (분산형태, 설치)

<br>

## 📝 소프트웨어 아키텍처 패턴유형

- **계층화 패턴**
  - 하위모듈(추상화) → 상위모듈에 서비스 제공
- **클라이언트-서버 패턴**
  - 여러 클라이언트 서비스요청 → 한 서버 서비스 제공
- **파이프-필터 패턴**
  - Source → Pipe1 → Filter1 → Pipe2 → Filter2 → Pipe3 → Sink
  - 데이터 스트림으로 처리, 단방향 패턴
  - 서브 시스템이 입력데이터 처리 → 다음 서브 시스템으로 넘김
  - Filter 재사용, 확장 용이 but 필터 간 데이터 이동에서 데이터변환 오버헤드 발생
- **브로커 패턴**
  - Client Request → Broker가 Resgistry에 있는 적합한 서비스로 Redirection ← Server가 기능 Publish
  - 분산 시스템, 원격 서비스로 상호작용
- **모델-뷰-컨트롤러 패턴 (MVC)**
  - Client Request → Controller(server) → Model Call → Model result → Controller가 화면생성요청 → View Response
  - Model : 핵심기능, 데이터 보관
  - 컴포넌트의 분리 : 서로영향X, 재사용O, 대화형 애플리케이션 구축에 적합
- **마스터-슬레이브 패턴**
  - Master(연산, 통신, 조정) → Slaves(제어, 동기화대상, 데이터수집)
  - 실시간 시스템에 사용

<br>

## 📝 소프트웨어 아키텍처 비용평가모델 종류

- SAAM : 변경용이성, 기능성 평가 (경험 없는 조직에도 사용 가능)
- ATAM : 품질속성 간 이해상충 관계(Trade-off) 평가
- CBAM : ATAM + 경제성평가 (비용평가모델 Cost Benefit)
- ADR : 구성요소 간 응집도 평가
- ARID : ATAM + ADR (특정부분 품질요소에 집중하는 비용평가모델)

<br>

## 📝 디자인 패턴 종류

- **생성패턴** <b><span style='color:#2D3748; background-color:#fff5b1'>(생빌 프로 팩앱싱)</span></b> : 객체 인스턴스 생성, 클래스 정의, 객체생성방식 구조화, 캡슐화
  - Builder : 객체생성(과정)과 구현(표현) 방법 분리 → 동일 절차로 다른 결과 구현
  - Prototype : 일반적인 원형 생성 → 기존 객체 복제 → 필요한 부분만 수정
  - Factory Method : 인터페이스(상위클래스)와 실제 객체 생성 클래스(하위클래스)의 분리
  - Abstract Factory : 추상적이면서 동일 주제의 다른 팩토리 묶음 → 사용자에게 인터페이스(API) 제공
  - Singleton : 한 클래스에 한 객체만 → 어디서든 참조 가능

<br>

## 📝 OSI 7계층


# 📂 요구사항 확인


- 요구사항 개발 프로세스
- 요구사항 도출 단계 주요 기법 (델파이, 설문조사, 브레인스토밍)
- 정형기술 검토 (동료검토, 워크스루, 인스펙션)
