---
layout: single
title: "[정처기] 프로그래밍 언어 활용"
categories: 
    - EIP
tags: 
    - [정처기, 정처기실기]
toc: true
toc_sticky: true
---

# <b>📂 기본 문법 활용하기</b>

## <b>📝 프로그래밍 기본 사항</b>

- 진수 (Antilogarithm) : 특정 개수의 숫자만 이용해 수를 나타내는 수 체계
- 아스키코드 (ASCII) : 미국 ANSI에서 표준화한 정보교환용 부호체계

    |10진수|부호|
    |:---:|:---:|
    |0|NULL|
    |32|' '(space)|
    |48|0|
    |49|1|
    |65|A|
    |97|a|

<br>

## <b>📝 데이터 타입</b>
 : 프로그래밍 언어에서 데이터를 식별하는 형태

|데이터타입|정의 | C언어 | Java |Python|
|:---|:---|:---:|:---:|:---:|
|불린 (Boolean)|조건의 참/거짓 판단||true, false|True, False|
|문자 (Character)|- 문자 하나를 저장<br>- 숫자로 메모리에 저장|&nbsp;char&nbsp;&nbsp;|char||
|문자열 타입 (String)|여러 문자 저장|char []| String||
|정수 타입 (Integer)|정수값 저장 | int | int ||
|부동 소수점 (Floating Point)| 소수점 포함하는 실수 저장 | float | double||

<br>

## <b>📝 변수</b>
 : 값을 주기억장치에 저장하기 위한 공간

- static 변수
  - 프로그램이 시작될 때 처음 한 번만 변수 초기화
  - 종료 전까지 메모리 유지
  - 함수에 의해 변수 선언 부분이 여러 번 호출되어도 초기화X

<br>

## <b>📝 배열</b>
 : 같은 타입의 변수들로 이루어진 집합

- 1차원 배열 선언
  - C언어
    - int a[5];
    - int[] a;
    - int a[5] = {1,2};
    - int[] a = {1,2};
  - Java
    - int []a = new int[3];
    - int a[] = new int[3];
    - int []a = {3,4};
- 2차원 배열 선언
  - C언어
    - int a[행][열];
    - int a[행][열] = {};
  - Java
    - int [][]a = new int[행][열];
    - int a[][] = new int[행][열];
    - int [][]a = {{1,2}, {3}, {4,5,6}};

<br>

## <b>📝 포인터</b>
 : 변수의 주소를 저장

```
int a = 10;
int* b = &a;            // a의 주소가 포인터 변수 b에 저장
printf("%d %d", a, *b)  // b가 기리키는(*) 값은 a이므로 a = *b
```

### <b>📌 1차원 배열과 1차원 포인터</b>

- <b><span style='color:#006DD7'>1차원 배열에서 배열명만 단독으로 사용하면 1차원 포인터와 동일</span></b>
- 값을 가리키는 경우
  - 배열명[요소]
  - *(배열명 + 요소)
  - 포인터[요소]
  - *(포인터 + 요소)
- 배열명 == &배열명[0] == 배열의 주소
- 배열명[0] == *배열명 == 배열의 0번지 값

```
int a[3] = {1,2};
int *p = a;
```

- a 단독으로 쓰면 포인터 → <b><span style='color:#006DD7'>*a</span></b>는 값
- a = p = &a[0]
 : 배열 a의 주소
- a[0] = p[0] = *a = *p
 : 배열 a의 0번지 값 (=1)
- (a+1) = (p+1) = &a[1]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소
- *(a+1) = *(p+1) = a[1]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소가 가리키는 값 (=2)

### <b>📌 2차원 배열과 1차원 포인터</b>

- <b><span style='color:#006DD7'>2차원 배열에서 배열명만 단독으로 사용하면 2차원 포인터와 동일</span></b>
- 값을 가리키는 경우
  - <b><span style='color:#67C71F'>*</span></b>배열명[요소]
  - <b><span style='color:#67C71F'>**</span></b>(배열명 + 요소)
  - <b><span style='color:#67C71F'>1차원포인터</span></b>[요소]
  - *(<b><span style='color:#67C71F'>1차원포인터</span></b> + 요소)

```
int a[3][2] = {1,2,3,4,5,6};
int *p = a[1];
```

- a 단독으로 쓰면 2차원 포인터
- a[] 형태로 쓰면 1차원 포인터 → <b><span style='color:#006DD7'>*a[]</span></b>는 값
- a[0] = &a[0][0]
 : 배열 a의 주소
- *a[0] = **a
 : 배열 a의 0번지의 값 (=1)
- *(a+1) = a[1] = &a[1][0]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소
- **(a+1) = *p = p[0]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소가 가리키는 값 (=2)
- *(p+1) = p[1] = a[1][1]
 : a[1]이 가리키는 &a[1][0]에서 1칸 뒤 값 (=4)

### <b>📌 2차원 배열과 포인터 배열</b>

```
int a[3][2] = {1,2,3,4,5,6};
int *p[3] = {a[2], a[0], a[1]};
```

- 배열 a의 2, 0, 1번지 주소(1차원 포인터)를 포인터배열 p에 저장
- a[2][0] = p[0][0] = *p[0] = 5

### <b>📌 2차원 배열과 2차원 포인터</b>

- <b><span style='color:#006DD7'>2차원 배열에서 배열명만 단독으로 사용하면 2차원 포인터와 동일</span></b>
- 값을 가리키는 경우
  - 배열명[요소][요소]
  - *배열명[요소]
  - **(배열명 + 요소)

```
int a[3][2] = {1,2,3,4,5,6};
int (*p)[2] = a;
int (*q)[2] = a+1;
```

- 2차원 배열 변수 p, q에 a 배열의 0, 1번지 주소를 2차원 포인터 변수에 저장
- a 단독으로 쓰면 2차원 포인터
- a[0][0] = p[0][0] = 1
- a[1][0] = p[1][0] = q[0][0] = 3

### <b>📌 1차원 배열과 문자열</b>

- <b><span style='color:#006DD7'>문자열을 초기화할 때 마지막에 NULL 문자 삽입됨</span></b>
- 배열 선언은 글자수보다 1 이상 큰 값으로
- 초기화 시 배열크기를 명시하지 않으면 문자열의 문자수+1 만큼 배열 자동 생성
- printf함수에서 %s로 문자열을 읽을 때 <b><span style='color:#006DD7'>시작 주소부터 NULL 직전값까지</span></b> 출력

```
char a[7] = "Hello";
printf("%s\n", a);      // Hello
printf("%s\n", a+1);    // ello
```

### <b>📌 2차원 배열과 문자열</b>

- 문자열을 여러 개 정의할 때 2차원 배열 사용

```
char a[2][8] = {"Hello", "Exciting"};
printf("%s\n", a[0]);   // Hello
printf("%s\n", a[1]);   // Exciting
a[0][4] = NULL
printf("%s\n", a[0]+2);   // ll
printf("%s\n", a[1]+3);   // iting
```

<br>

## <b>📝 자료형</b>

### <b>📌 자바 자료형</b>

1. **HashSet**
    - 중복된 원소를 허용하지 않는 집합(Set)의 성질을 가진 클래스 (순서 X, 자동정렬)
    - 선언
      - `Set 변수명 = new HashSet();`
      - `HashSet 변수명 = new HashSet();`
    - 메서드
      - `add(값)` : 값 추가, 중복허용 X
      - `remove(값)` : 값 삭제
      - `size()` : HashSet의 원소 개수
2. **ArrayList**
    - 크기가 가변적으로 변하는 선형리스트의 성질을 가진 클래스 (순서 O → 인덱스로 접근)
    - 선언
      - `List 변수명 = new ArrayList();`
      - `ArrayList 변수명 = new ArrayList();`
    - 메서드
      - `add(값)` : 값 추가
      - `add(인덱스, 값)` : 해당 인덱스에 값 추가
      - `remove(인덱스)` : 해당 인덱스의 값 제거
      - `get(인덱스)` : 해당 인덱스의 값 가져오기
      - `size()` : HashSet의 원소 개수
3. **LinkedList**
    - 데이터를 저장하는 노드가 전후 노드 상태를 알고 있는 자료구조 클래스
    - 선언
      - `Map 변수명 = new HashMap();`
      - `HashMap 변수명 = new HashMap();`
    - 메서드
      - `put(키, 값)` : 해당 키에 값 추가
      - `remove(키)` : 해당 키의 값 제거
      - `get(키)` : 해당 키의 값 가져오기
      - `size()` : HashMap의 원소 개수
4. **HashMap**
    - 키-값으로 구성된 객체를 저장하는 자료구조 클래스

### <b>📌 파이썬 자료형</b>

1. **세트형**
   - 중복을 허용하지 않는 집합 성질을 가지는 자료구조 (순서 X, 자동정렬)
   - 선언
     - `세트명 = set([요소1, 요소2, ...])`
     - `세트명 = {요소1, 요소2, ...}`
   - 메서드
     - `add(값)` : 값 1개 추가
     - `update([값1, 값2, ...])` : 여러 값을 한꺼번에 추가
     - `remove(값)` : 특정 값 제거
2. **리스트형**
   - 크기가 가변적으로 변하는 선형리스트 성질을 가지는 자료구조
   - 선언
     - `리스트명 = [요소1, 요소2, ...]`
   - 메서드
     - `append(값)` : 리스트 마지막에 값 추가
     - `insert(인덱스, 값)` : 인덱스 위치에 값 삽입
     - `remove(값)` : 해당 값 제거 (여러 개 있는 경우 맨 앞의 것 제거)
   - 인덱싱 (리스트에 n개의 값이 있을 때)
        |첫 번째|두 번째| ... |뒤에서 두 번째|마지막|
        |:---:|:---:|:---:|:---:|:---:|
        |0|1||(n-2)|(n-1)|
        |-n|-(n-1)||-2|-1|
   - 리스트 슬라이싱 : 여러 데이터에 동시에 접근하는 기법
     - `리스트명[시작인덱스 : 종료인덱스 : 스텝]` : 종료인덱스 전까지 슬라이싱
3. **튜플형**
   - 초기에 선언된 값에서 생성/삭제/수정이 불가능한 형태의 자료구조
   - 선언
     - `리스트명 = (요소1, 요소2, ...)`
   - 인덱싱 (튜플에 n개의 값이 있을 때)
        |첫 번째|두 번째| ... |뒤에서 두 번째|마지막|
        |:---:|:---:|:---:|:---:|:---:|
        |0|1||(n-2)|(n-1)|
        |-n|-(n-1)||-2|-1|
   - 튜플 슬라이싱
     -  `튜플명[시작인덱스 : 종료인덱스 : 스텝]` : 종료인덱스 전까지 슬라이싱
4. **딕셔너리형**
   - 키-값으로 구성된 객체를 저장하는 자료구조
   - 선언
     - `딕셔너리명 = {키1:값1, 키2:값2, ...}`
   - 요소 추가
     - `딕셔너리명[키] = 값`
   - 요소 삭제
     - `del 딕셔너리명[키]`