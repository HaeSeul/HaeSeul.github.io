---
layout: single
title: "[정처기] 애플리케이션 통합 테스트 및 성능 개선"
categories: 
    - EIP
tags: 
    - [정처기, 정처기실기]
toc: true
toc_sticky: true
---

# 📂 애플리케이션 테스트 시나리오 작성

## 📝 테스트 레벨
 : 함께 편성, 관리되는 테스트 활동의 그룹, 각 레벨은 독립적

1. 단위 테스트 (Unit Test)
 : 모듈, 컴포넌트 중심 테스트
   - 기법 : 인터페이스 / 자료구조 / 실행경로 / 오류처리 테스트 → 라인 커버리지 사용
   - 구분 : 명세 기반 테스트 (블랙박스), 구조 기반 테스트 (화이트박스)
2. 통합 테스트 (Integration Test)
 : 각 모듈 간 인터페이스 중심 테스트, 타 시스템과 연동되는지
   - 기법 : 빅뱅 / 상향식 / 하향식 테스트
   - 단위 테스트 끝난 모듈, 컴포넌트 → 설계 단계에서 제시한 것과 동일한지 확인
3. 시스템 테스트 (System Test)
 : 통합된 단위 시스템 기능이 시스템에서 정상 수행되는지
   - 기능적 요구사항 테스트 : 명세서 기반 블랙박스 테스트 (명세서, 비즈니스 절차, 유스케이스)
   - 비기능적 요구사항 테스트 : 구조 기반 화이트박스 테스트 (성능/회복/보안 테스트, 메뉴구조)
4. 인수 테스트 (Acceptance Test)
 : 최종 사용자, 업무 이해관계자가 테스트 → 계약상 요구사항 만족? → 운영 여부 결정
   - 사용자 인수 테스트 (사용자가 테스트)
   - 운영상의 인수 테스트 (관리자가 시스템 인수 시 테스트)
   - 계약 인수 테스트 (계약 조건 준수?)
   - 규정 인수 테스트 (규정 준수?)
   - 알파 테스트 (선택된 사용자 → 개발자 환경, 통제된 상태 → 개발자와 함께 수행)
   - 베타 테스트 (실제 환경 → 개발자 없이 수행) = 필드 테스팅

<br><br>

# 📂 애플리케이션 통합 테스트

## 📝 단위 테스트

- 개별적인 모듈/컴포넌트 테스트
 → 모듈을 단독 실행하는 Test Bed 환경 필요
- 언제나 테스트 결과는 동일해야 함
<br>
- Mock 객체 생성 프레임워크 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>더스드 스가</span></b>
 : 독립적인 컴포넌트 테스트를 위해 스텁의 객체 지향 버전인 목 객체 필요
  - Dummy : 테스트할 때 객체만 필요하고 기능은 필요 없을 때, 예외 상황 수행
  - Stub : 더미 객체에의 단순 기능 수행, 특정값 리턴
  - Driver : 테스트 대상 하위 모듈 호출, 파라미터 전달, 모듈 테스트 결과 도출
  - Spy : 테스트 대상 클래스와 협력하는 클래스로 가는 출력 검증
  - Fake : 실제 협력 클래스의 기능 대체

<br>

## 📝 통합 테스트

- 비점증 방식 : 빅뱅 방식
  - 모든 컴포넌트 사전 통합 → 전체 프로그램 한 번에 테스트
  - 드라이버/스텁 없이 실제 모듈로 테스트
  - 장 : 단시간 테스트, 작은 시스템에 유리
  - 단 : 장애 위치 파익 어려움, 모든 모듈이 개발되어야 가능
- 점증 방식
  - <b><span style='color:#006DD7'>하향식 통합 (Top Down)</span></b>
   : 메인 제어 모듈로부터 아래로 통합하며 테스트
    1. 메인 제어 모듈 : 작성된 프로그램, 하위 모듈 제어
    2. 위 → 아래 방향 : 검사 초기에 시스템 구조 파악
    3. 더미 모듈 <b><span style='color:#EF6F53'>스텁</span></b> : 모듈 및 모든 하위 컴포넌트 대신
    4. 스텁이 실제 모듈로 : 깊이-우선 or 너비-우선 방식
    5. 각 모듈 통합하며 테스트
    6. 테스트 후 스텁이 실제 모듈로 작성
  - <b><span style='color:#006DD7'>상향식 통합 (Bottom Up)</span></b>
   : 최하위 레벨 모듈로부터 위로 통합하며 테스트
    1. 클러스터로 결합 : 하위 모듈 기능 수행
    2. 더미 모듈 <b><span style='color:#EF6F53'>드라이버</span></b> : 상위 모듈에서 데이터 입출력 확인
    3. 각 통합된 클러스터 단위 테스트
    4. 테스트 후 각 클러스터는 위로 결합, 드라이버는 실제 모듈로 대체
  - <b><span style='color:#006DD7'>샌드위치 통합</span></b>
   : 상향식 + 하향식 ⇒ 병렬 테스트 가능, 시간 절약, 비용 큼

<br>

## 📝 테스트 자동화 도구 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>정실성통</span></b>

1. 정적 분석 도구 (Static Analysis Tools)
 : 앱 실행X, 소스코드 이해 바탕으로 자료/논리흐름 분석 → 비정상 패턴 발견
2. 테스트 실행 도구 (Test Execution Tools)
 : 테스트를 위해 작성된 스크립트 실행
    - 데이터 주도 접근 방식
        : 스프레드 시트에 테스트 데이터 저장
         → 다양한 테스트 데이터 → 동일 케이스 반복 실행
    - 키워드 주도 접근 방식
        : 스프레드 시트에 테스트 데이터 + 키워드(수행동작 정의) 저장
         → 키워드 테일러링 가능
3. 성능 테스트 도구 (Performance Test Tools)
 : 가상 사용자 생성 → 처리량, 응답/경과 시간, 자원 사용률 테스트 → 성능 목표 달성했는지 확인
4. 테스트 통제 도구 (Test Control Tools)
 : 테스트 관리 도구, 형상 관리 도구, 결함 추적/관리 도구

<br>

## 📝 테스트 하네스 (Test Harness) ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>드스슈 케시스목</span></b>
 : 테스트 지원하는 코드, 데이터 → 단위 테스트에 사용하기 위해 개발자가 작성

- 테스트 드라이버 (Test Driver)
   - 상향식 통합시험, 상위모듈, 필요에 따라 파라미터 전달
   - 상위 모듈의 데이터 입출력 확인(모듈 테스트 수행 후 결과 확인)하는 더미 모듈
   - 상위 모듈의 흐름을 작성해야 함 (개발 어려움)
- 테스트 스텁 (Test Stub)
   - 하향식 통합시험, 하위모듈
   - 일시적으로 필요한 조건만으로 임시 제공되는 더미 모듈
   - 하위 모듈의 리턴값만 전달하면 됨
- 테스트 슈트 (Test Suite)
   - 단순 테스트 케이스들의 집합
- 테스트 케이스 (Test Case)
   - 입력값, 실행조건, 기대값의 집합
- 테스트 시나리오 (Test Scenario)
   - 테스트가 필요한 상황 작성
- 테스트 스크립트 (Test Script)
   - 테스트 케이스의 절차 (Test Step, Test Procedure)
- 목 오브젝트 (Mock Object)
   - 사용자 행위를 조건부로 사전에 입력 → 그 상황에 예정된 행위를 수행하는 객체

<br><br>

# 📂 애플리케이션 테스트 결과 분석

## 📝 테스트 결과 분석

- 소프트웨어 결함 : 개발자 오류로 인해 생긴 문서/코딩상의 결점, 설계와 다르게 동작
  - 오류 (Error) : 결함(Defect = 결점, 버그)의 원인, Human Mistake
  - 결점 (Fault) : 오류(Error) 있는 경우 발생 → 시스템 고장(Failure) 유발
  - 버그 (Bug) : 오류(Error)로 인한 예상치 못한 결과
  - 고장 (Failure), 문제 (Problem) : 제품에 포함된 결함이 실행될 때 발생
- 테스트 리포팅 : 테스트 결과 정리, 테스트 요약, 품질상태, 테스트 결과, 실행절차 및 평가

<br>

## 📝  결함 관리
 : 단계별 테스트 후 발생한 결함의 재발 방지, 유사 결함 발견 시 처리시간 단축을 위해 결함 추적/관리

- 결함 관리 프로세스 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>계기검수 재추최</span></b>
  - 결함관리 계획 → 결함 기록 → 검토 → 수정 → 재확인 → 최종 결함 분석 및 보고서 작성
- 결함 분석 : 테스트 케이스 실행 후 발견된 결함 분석해 테스트 결함 보고서 작성 → 개발자에게 통보
  - 구체화 (Specifiaction) : 입력값, 테스트절차, 테스트환경을 명확히 파악
  - 고립화 (Isolation) : 입력값, 테스트절차, 테스트환경 중 어떤것이 문제인지 분석
  - 일반화 (Generalization) : 결함 발생 요소를 최대한 일반화
- 결함 생명주기
  - 결함등록(Open) → 검토(Reviewed) → 할당(Assigned) → 수정(Resolved) → 확인(Verified)/보류(Deffered) → 종료(Closed)/재등록(Reopen)
- 결함 추이 분석 : 결함 속성 분석 → 향후 어떤 결함 발생할지 추정
  - 결함 분포 분석 : 모듈, 컴포넌트 특정 속성에 해당하는 결함 수
  - 결함 추세 분석: 테스트 진행 시간 흐름에 따른 결함 후
  - 결함 에이징 분석 : 결함 지속 시간 측정

<br><br>

# 📂 애플리케이션 개선 조치사항

## 📝 테스트 커버리지
 : 테스트 품질 측정 기준

- 기능 기반 커버리지 : 앱 전체 기능이 모수, 실제 테스트가 수행된 기능 수 측정
- 라인 커버리지 : 전체 소스 코드 라인 수가 모수, 시나리오가 수행한 코드 라인 수 측정
- 코드 커버리지 : 테스트 충분성 지표 (구조 코드 자체가 얼마나 테스트되었는지 측정)

<br>

## 📝 결함의 식별 및 관리

- 결함 심각도별 분류 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>치주 보경단</span></b>
  - 치명적 결함 (Critical) : 테스트를 완전히 방해 → 데이터 손실, 시스템 충돌
  - 주요 결함 (Major) : 기능 장애
  - 보통 결함 (Normal) : 사소한 기능 오작동
  - 경미한 결함 (Minor) : 표준 위반, UI 잘림 등 사용상의 불편함
  - 단순 결함 (Simple) : 사소한 버그, 기능에는 영향X, 미관상 좋지 않음
- 결함 우선순위
  - 결정적 (Critical) : 전체 기능 동작 X, 메모리 누수
  - 높음 (High) : 종료 기준에 대한 테스트 위해 수정되어야 함
  - 보통 (Medium) : 올바른 에러 메시지 출력X
  - 낮음 (Low) : 사용자경험 관련

<br><br>

# 📂 애플리케이션 성능 개선

## 📝 애플리케이션 성능 분석

- 애플리케이션 성능 측정 지표 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>처응경자</span></b>
  - **처리량** (Throughput) : 주어진 시간에 처리 가능한 트랜잭션 수
  - **응답시간** (Response Time) : 입력 - 출력까지
  - **경과시간** (Turnaround Time) : 입력 - 처리 - 결과 출력까지
  - **자원사용률** (Resource Usage) : 트랜잭션 처리 동안 CPU, 메모리, 네트워크 사용량

- 성능 분석 도구
  - **성능 테스트 도구** : 시스템 부하/스트레스로 처리량/응답시간/경과시간 점검 (JMeter, LoadUI, OpenSTA)
  - **시스템 모니터링 도구** : 자원사용량 확인 (Scouter, Zabbix)

- 애플리케이션 성능 저하 원인
    1. 데이터베이스 관련 성능 저하 원인
        - DB Lock, 불필요한 DB Fetch, Connection Leak, Connection Pool Size, Commit 관련
    2. 내부 로직으로 인한 성능 저하 원인
        - 웹 앱의 인터넷 접속 불량, 특정파일 업로드/다운로드로 인한 성능 저하, 비정상 오류 처리
    3. 외부 호출로 인한 성능 저하
        - 외부 호출이 장시간 수행, 타임아웃
    4. 잘못된 환경 설정, 네트워크 문제

- 애플리케이션 성능 테스트 수행 절차
    1. 성능 테스트 도구 설치
    2. 테스트 환경 설정
    3. 시나리오 생성
    4. 성능 테스트 실행 및 모니터링

<br>

## 📝 애플리케이션 성능 개선

- 소스 코드 최적화
  - <b><span style='color:#006DD7'>Bad Code</span></b> : **다른 개발자가 로직을 이해하기 어렵게 작성된 코드**
    - 사례
      - 외계인 코드 : 오래되거나 참고문서, 개발자가 없어 유지보수 어려움
      - 스파게티 코드 : 작동은 정상 but 코드 작동 파악 어려움
      - 알 수 없는 변수명
      - 로직 중복
    - 유형
      - 오염 : 기능을 수행하지 못하는 컴포넌트 존재
      - 문서부족 : 현재 코드와 문서의 불일치, 개발자의 지식부족
      - 의미 없는 이름
      - 높은 결합도
      - 아키텍처 침식 : 아키텍처가 구별되지 않고 여러 솔루션으로 이루어져 품질 저하
  - <b><span style='color:#006DD7'>Clean Code</span></b> : **가독성 높고 단순, 의존성 줄이고 중복 최소화해 깔끔하게 잘 정리된 코드**
    - 특징
      - 중복 코드 제거로 애플리케이션 설계 개선
      - 가독성이 높아 기능 이해 쉬움
      - 버그 찾기 쉬움, 프로그래밍 속도 향상
    - 원칙 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>가단의 중추</span></b>
      - **가독성** (이해하기 쉬운 용어, 들여쓰기)
      - **단순성** (한 번에 한 가지만 처리)
      - **의존성 최소** (코드 변경이 다른 부분에 영향 없게)
      - **중복성 제거**
      - **추상화** (상세 내용은 하위에 구현)
    - 유형
      - 유의미한 이름
      - 간결, 명확한 주석
      - 보기 좋은 배치
      - 작은 함수
      - 읽기 쉬운 제어 흐름
      - 오류 처리
      - 클래스 분할 배치
      - 느슨한 결합 (클래스 간 결합도 최소화)
      - 코딩 형식 기법 적용 (호출하는 함수 먼저 배치, 변수는 함수 맨 처음에 선언 등)

<br>

## 📝 소스 코드 품질분석

1. 정적 분석 도구 (Static Analysis Tools)
 : 앱 실행X, 소스코드 이해 바탕으로 자료/논리흐름 분석 → 비정상 패턴 발견
    - pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura
2. 동적 분석 도구 (Dynamic Analysis Tools)
 : 앱 실행, 코드에 존재하는 메모리 누수 현황 발견, 스레드 결함 분석
    - Avalanche, Valgrind

<br>

## 📝 애플리케이션 성능 개선 방안

- 소스 코드 최적화 기법 적용 (느슨한 결합)
- 아키텍처 조정 (Factory Mathod 패턴 사용)
- 프로그램 호출 순서 적용
- 소스 코드 품질분석 도구 활용
- <b><span style='color:#006DD7'>리팩토링</span></b>으로 성능 개선
 : 기능 변경 없이 복잡한 소스코드 수정/보완해 유지보수성 향상
  - 목적 : 유지보수성 향상, 유연한 시스템, 생산성 향상, 품질향상