---
layout: single
title: "[정처기] 요구사항 확인"

categories:
  -  EIP
tags:
  - [정처기, 정처기실기, 요구사항]

toc: true
toc_sticky: true
---

# 📂 소프트웨어 개발방법론

## 📝 소프트웨어 생명주기 모델 (SDLC)


### SDLC 프로세스 <b><span style='color:#2D3748; background-color:#fff5b1'>(분설구테유)</span></b>

   - 요구사항 분석 - 설계 - 구현 - 테스트 - 유지보수


### SDLC 모델종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(폭프나반)</span></b>

  - **폭포수 모델**
    - Boehm, <b><span style='color:#006DD7'>선형 순차적</span></b>, 고전적
    - 단계별 정의, 산출물 명확
    - 절차 : 타당성검토 → 계획 → 분설구테유
    - 장점 : 이해 굿, 관리 굿
    - 단점 : 요구사항 변경이 어려움
  - **프로토타입 모델**
    - 고객 <b><span style='color:#006DD7'>피드백</span></b> 반영한 주요 기능 → 프로토타입으로 구현
    - 공동의 참조 모델 제공 to 발주자 & 개발자
    - 절차 : 요구사항 분석 → 프로토타입 개발/<b><span style='color:#006DD7'>평가</span></b> → 구현 → 테스트
    - 장점 : 요구분석 굿, 타당성검증 가능
    - 단점 : 프로토타입 폐기 시 비용증가
  - **나선형 모델 (Spiral)**
    - 점진적개발 → 개발위험 최소화
    - 절차 : 계획/정의 → <b><span style='color:#006DD7'>위험분석</span></b> → 개발 → <b><span style='color:#006DD7'>고객평가</span></b> → 반복 <b><span style='color:#2D3748; background-color:#fff5b1'>(계위개고)</span></b>
    - 장점 : 위험성 감소, 변경 대처 굿
    - 단점 : 단계 반복에 따른 관리 어려움
  - **반복적 모델 (Iteration)**
    - 증분 방식, 병행 개발 → 통합 or 반복개발
    - 장점 : 병행 개발 → 일정 단축
    - 단점 : 병행 개발 → 관리비용 증가

<br>

## 📝 소프트웨어 개발방법론 종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(구정객컴애제)</span></b>

  - **구조적 방법론**
    - 분할 & 정복 : 전체시스템 → 기능별 개발 → <b><span style='color:#006DD7'>프로세스 중심의 정형화된 하향식 통합</span></b>
    - 나씨-슈나이더만 차트 : 구조적, 도형식 표현, 제어 논리 기술, 시각적 식별 가능
  - 정보공학 방법론
    - 데이터 중심 : 상호 연관성 있게 통합
  - 객체지향 방법론
  - **컴포넌트 기반 방법론 (CBD)**
    - 소프트웨어를 구성하는 컴포넌트를 조립해 새 응용 프로그램 작성
    - 재사용 굿, 생산성 굿, 품질 굿, 유지보수 비용 최소화, 복잡성 최소화(독립적인 컴포넌트 단위)
  - **애자일 방법론**
    - <b><span style='color:#EF6F53'>XP</span></b> (실용성강조)
      - 5 가치 <b><span style='color:#2D3748; background-color:#fff5b1'>(용단의피존)</span></b>
       : 용기, 단순성, 의사소통, 피드백, 존중
      - 12 기본원리
       : Pair programming, Collective ownership, Continuous integration, Planning process, Small release, Metaphor, Simple design, Test driven develop, Refactoring, 40-hour work, On-site customer, Coding standard
    - <b><span style='color:#EF6F53'>SCRUM</span></b> (프로젝트 관리 중심) : 매일 정해진 시간/장소에서 짧은 시간 개발
      - <b><span style='color:#006DD7'>Backlog</span></b> : 요구사항
      - <b><span style='color:#006DD7'>Sprint</span></b> : 2~4주 짧게 반복 개발
      - <b><span style='color:#006DD7'>Scrum Meeting</span></b> : 매일 15분 미팅
      - <b><span style='color:#006DD7'>Scrum Master</span></b> : 프로젝트 리더
      - <b><span style='color:#006DD7'>Sprint Retrospective</span></b> : 스프린트 주기 회고
      - <b><span style='color:#006DD7'>Burn Down Chart</span></b> : 남은 백로그 대비 시간을 차트로 표현
    - <b><span style='color:#EF6F53'>Lean</span></b> : JIT(Just In Time), 칸반(Kanban) 보드 사용
      - 7 원칙 <b><span style='color:#2D3748; background-color:#fff5b1'>(낭품지 확인사전)</span></b>
       : 낭비제거, 품질내재화, 지식창출, 늦은 확정, 빠른인도, 사람존중, 전체최적화
  - **제품 계열 방법론**
    - 특정 제품에 적용하고 싶은 <b><span style='color:#006DD7'>공통 기능을 정의</span></b>해서 개발
    - 임베디드 소프트웨어 작성에 유용

<br>

## 📝 비용산정모델 분류

### 하향식 : 전문가, 조정자를 통해 비용산정
  - 전문가 감정 기법 : 편리, 신속, 개인적, 주관적
  - 델파이 기법 : 여러 전문가 의견 종합 → 1명의 조정가
   
### 상향식 : 세부 요구사항/기능에 따라 비용산정
  - **LOC (Lines of Code)**
    - 원시 코드 라인 수의 낙관치, 중간치, 비관치 측정 → 예측치 → 비용산정
    - 예측치 : (낙관치 + 4*중간치 + 비관치) / 6
  - **Man Month**
    - MM = LOC / 프로그래머의 월간 생산성
    - 프로젝트 기간 = MM / 프로젝트 인력
  - **COCOMO** (COnstructive COst MOdel)
    - 보헴, 프로그램 규모에 따른 비용 산정
    1. <b><span style='color:#006DD7'>조직형, 단순형 (organic)</span></b> : 5만 라인 이하 소규모, 일괄 자료처리
    2. <b><span style='color:#006DD7'>반분리형, 중간형 (semi-detached)</span></b> : 30만 라인 이하 유틸개발(트랜잭션 처리, DB관리시스템, 컴파일러, 인터프리터 등)
    3. <b><span style='color:#006DD7'>임베디드형 (embedded)</span></b> : 30만 라인 이상 시스템 프로그램 개발(초대형 트랜잭션, 실시간 처리 시스템)
  - **푸트남 (Putnam) 모형**
    - <b><span style='color:#006DD7'>생명주기 예측모형</span></b> : 개발주기 단계별 요구할 인력 분포 가정
    - Rayleigh-Norden 곡선의 노력분포도 기초 (시간에 따른 함수)
    - 자동화 추정 도구 : <b><span style='color:#006DD7'>SLIM</span></b>
  - **FP (Function Point)**
    - 기능별 가중치 → 총 기능 점수 계산
    - 비용 산정 요소 : 자료입출력, 명령어, 데이터파일, 필요한 외부 루틴과의 인터페이스
    - 프로그래밍 언어에 독립적
    - 자동화 추정 도구 : <b><span style='color:#006DD7'>ESTIMACS</span></b>
  - 개발 단계별 노력 (Effort Per Task) 기법
    - LOC의 확장 : LOC을 SDLD 단계별 적용 → 모든 단계의 비용 산정

<br>

## 📝 일정관리모델 종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(주펄중)</span></b>

  - <b><span style='color:#006DD7'>CPM (Critical Path Method) : 주 공정법</span></b>
    - Critical Path (<b><span style='color:#006DD7'>임계경로</span></b>) : 가장 긴 경로
    - 여러 작업 수행순서 얽힌 프로젝트의 일정 계산
  - PERT (Program Evaluation and Review Technique)
    - 일 순서 정리하는 수렴기법
    - 비관치, 중간치, 낙관치의 3점 추정방식
  - CCPM (Critical Chain Project Management) : 중요 연쇄 프로젝트 관리
    - 주공정 연쇄법 → 자원 제약사항 고려해 일정 작성

<br><br>

# 📂 현행 시스템 분석


## 📝 소프트웨어 아키텍처 4+1 뷰 <b><span style='color:#2D3748; background-color:#fff5b1'>(유논프구배)</span></b>

고객 요구사항 정리한 시나리오 → 4개의 관점에서 바라봄
- **Usecase View** : 다른 뷰 검증에 사용 (사용자 입장에서 인식되는 시스템의 기능 요구사항에 초점)
- **Logical View** : 기능적 요구사항이 어떻게 제공되는지 설명
- **Process View** : 비기능적 속성 표현
- **Implementation View** : 정적인 소프트웨어 모듈 구성 (컴포넌트 구조)
- **Deployment View** : 컴포넌트가 어떻게 아키텍쳐에 배치되는지 (분산형태, 설치)

<br>

## 📝 소프트웨어 아키텍처 패턴유형

- **계층화 패턴**
  - 하위모듈(추상화) → 상위모듈에 서비스 제공
- **클라이언트-서버 패턴**
  - 여러 클라이언트 서비스요청 → 한 서버 서비스 제공
- **파이프-필터 패턴**
  - Source → Pipe1 → Filter1 → Pipe2 → Filter2 → Pipe3 → Sink
  - 데이터 스트림으로 처리, 단방향 패턴
  - 서브 시스템이 입력데이터 처리 → 다음 서브 시스템으로 넘김
  - Filter 재사용, 확장 용이 but 필터 간 데이터 이동에서 데이터변환 오버헤드 발생
- **브로커 패턴**
  - Client Request → Broker가 Resgistry에 있는 적합한 서비스로 Redirection ← Server가 기능 Publish
  - 분산 시스템, 원격 서비스로 상호작용
- **모델-뷰-컨트롤러 패턴 (MVC)**
  - Client Request → Controller(server) → Model Call → Model result → Controller가 화면생성요청 → View Response
  - Model : 핵심기능, 데이터 보관
  - 컴포넌트의 분리 : 서로영향X, 재사용O, 대화형 애플리케이션 구축에 적합
- **마스터-슬레이브 패턴**
  - Master(연산, 통신, 조정) → Slaves(제어, 동기화대상, 데이터수집)
  - 실시간 시스템에 사용

<br>

## 📝 소프트웨어 아키텍처 비용평가모델 종류 <b><span style='color:#2D3748; background-color:#fff5b1'>(SACAA)</span></b>

- SAAM : 변경용이성, 기능성 평가 (경험 없는 조직에도 사용 가능)
- ATAM : 품질속성 간 이해상충 관계(Trade-off) 평가
- CBAM : ATAM + 경제성평가 (비용평가모델 Cost Benefit)
- ADR : 구성요소 간 응집도 평가
- ARID : ATAM + ADR (특정부분 품질요소에 집중하는 비용평가모델)

<br>

## 📝 디자인 패턴 종류

### 목적에 따른 디자인 패턴 유형 <b><span style='color:#2D3748; background-color:#fff5b1'>(생구행)</span></b>

- <b><span style='color:#EF6F53'>생성패턴</span></b> <b><span style='color:#2D3748; background-color:#fff5b1'>(생빌 프로 팩앱싱)</span></b>
 : 객체 인스턴스 생성, 클래스 정의, 객체생성방식 구조화, 캡슐화
  - Builder : 객체생성(과정)과 구현(표현) 방법 분리 → 동일 절차로 다른 결과 구현
  - Prototype : 일반적인 원형 생성 → 기존 객체 복제 → 필요한 부분만 수정
  - Factory Method : 인터페이스(상위클래스)와 실제 객체 생성 클래스(하위클래스)의 분리
  - Abstract Factory : 추상적이면서 동일 주제의 다른 팩토리 묶음 → 사용자에게 인터페이스(API) 제공
  - Singleton : 한 클래스에 한 객체만 → 어디서든 참조 가능

- <b><span style='color:#EF6F53'>구조패턴</span></b>
 : 클래스나 객체의 조합 → 더 큰 구조 형성
  - Bridge : 구현과 추상의 분리 → 독립적으로 확장 → 기능 클래스계층과 구현 클래스계층 연결
  - Decorator : 기존클래스 + 필요기능 결합 → 객체결합 → 동적으로 유연하게 기능확장 
  - Facade : 통합 인터페이스 → 시스템구조, 오류 파악 용이, 접근성
  - Flyweight : 클래스 경량화, 가상 인스턴스 제공 → 메모리절감
  - Proxy : 실제 객체에 대한 대리 객체 → 정보은닉, 메모리절감, 객체 접근제어
  - Composite : 트리 구조로 객체관계 구성 → 복합객체와 단일객체 같게 취급
  - Adapter : 클래스패턴(상속), 인스턴스패턴(위임) → 재사용 (기조 인터페이스에 덧씌움)

- <b><span style='color:#EF6F53'>행위패턴</span></b>
 : 클래스나 객체의 상호작용, 역할분담
  - Mediator : 객체 통신을 중재자가 통제 → 객체지향의 느슨한 결합 달성 + 상호작용의 유연한 변경
  - Interpreter : 여러 구문법 자체를 캡슐화해서 사용
  - Iterator : 내부구조 노출X → 복잡 객체 원소를 순차적으로 접근 가능
  - Template Method : 상위 추상클래스 - 기능 골격 제공
  -	Observer : 객체 상태변화 → 다른 객체 상태도 연동 (일대다 의존성) — 가장 느슨한 결합
  - State : 객체 상태 캡슐화(클래스화) → 상태에 따라 행위내용 변경
  - Visitor : 별도의 클래스에 연산 정의 → 해당 클래스 메서드가 각 클래스 돌아다니며 작업
  - Command : 한 추상클래스에 메서드 생성 (실행될 요구사항을 캡슐화) → 명령어에 맞게 서브클래스 호출
  - Strategy : 행위객체를 클래스로 캡슐화 → 동적으로 자유롭게 행위 변환 (필요할 때 서로 교환)
  - Memento : 객체 정보 저장 → 작업취소 기능이 필요할 때 요청 가능
  - Chain of Resonsibility : 한 요청을 2개 이상의 객체에서 처리


<br>

## 📝 OSI 7계층 <b><span style='color:#2D3748; background-color:#fff5b1'>(아파서 티내다 피)</span></b>

Application - Presentation - Session - Transport - Network - Data Link - Physical

### 1 - 물리 계층 (Physical) : Bit

- 개념 : 데이터 → 전기적, 물리적 신호(Bit)로 변환
- 장비 : Hub(네트워크로 컴퓨터 간 정보교환), Repeater(디지털 신호 증폭)

### 2 - 데이터링크 계층 (Data Link) : Frame

- 개념 : 링크 설정/유지/종료 + 물리적 연결 → 노드 간 동기화, 오류제어, 흐름제어, 회선제어
- 송신측 : 네트워크 계층의 패킷 → <b><span style='color:#006DD7'>프레임으로</span></b> 변환 → 물리게층으로 전달
- 프레임 : 헤더(<b><span style='color:#006DD7'>물리주소</span></b>) + 네트워크 계층 데이터 + <b><span style='color:#006DD7'>트레일러</span></b>(오류검출비트)
- 프로토콜
  - <b><span style='color:#006DD7'>HDLC</span></b> (High-level Data Link Control)
   : 동기식 비트 중심
  - PPP (Point-to-Point)
   : 노드 간 직접 연결
  - Frame Relay
   : 데이터프레임 단순 중계(Relay) + 다중화 기능만 수행 → 고속 데이터 전송 기술
  - ATM (Async Transport Model)
   : 비동기식 시분할 다중화 방식이 패킷형 전송 기술
  - 이외 : LLC, ALOHA 등
- 장비
  - <b><span style='color:#006DD7'>Switch</span></b> : 출발지에서 온 프레임 → <b><span style='color:#006DD7'>목적지 MAC 주소 기반</span></b> →  빠르게 전송
    - VLAN
     : 논리적 LAN → 브로드캐스트 도메인 구분 → 성능향상, 보안성 증대
    - STP (Spanning Tree Protocol)
     : 여러 스위치가 여러 경로로 연결 시 무한 루프 방지 → 한 경로로만 통신하도록
  - Bridge : LAN끼리 연결해주는 통신망 연결 장치
- 오류제어 (Error Correction)
  - 전진 오류 수정 (FEC) : 오류 스스로 수정
  - 후진 오류 수정 (BEC) : 오류 생기면 재전송 요구
    - <b><span style='color:#006DD7'>자동 반복 요청 (ARQ</span></b>; Automatic Repeat reQuest)
      - Stop-and-wait ARQ
       : ACK, NAK 수신할 때까지 중지 + 대기 + 정확한 수신여부 매번 확인
      - Go-back-N ARQ
       : NAK 수신 시 오류 발생한 프레임 이후 모든 데이터 프레임 재전송
      - Selective repeat ARQ
       : 에러 발생한 데이터 프레임만 재전송

### 3 - 네트워크 계층 (Network) : Packet

- 개념 : 패킷전달(발신지~최종 목적지까지), QoS를 위한 수단제공 to 전송계층
- 기능 : 라우팅, 패킷 포워딩, Inter-Networking
- 송신 : 전송계층의 세그먼트 → 패킷으로 변환 → 데이터링크 계층에 전달
- 패킷 : 헤더(<b><span style='color:#006DD7'>논리주소</span></b>) + 세그먼트
- 프로토콜
  - <b><span style='color:#006DD7'>IP</span></b> (Internet Protocol)
   : 패킷 단위로 데이터 교환 → 보낸 정보가 제대로 갔는지 보장X
  - <b><span style='color:#006DD7'>ARP</span></b> (Address Resolution Protocol)
   : IP주소(논리) → MAC주소(물리)로 변환
  - RARP (Reverse ARP)
   : MAC주소는 알지만 IP주소 모를 때 서버로부터 요청
  - <b><span style='color:#006DD7'>ICMP</span></b> (Internet Control Message)
   : IP패킷 처리 시 발생하는 문제 알려줌 (ping) → 8byte 헤더 + 가변길이 데이터 영역
  - IGMP (Internet Group Management)
   : 호스트 컴퓨터 - 인접 라우터 멀티캐스트 그룹 멤버십에 사용
  - 라우팅 프로토콜 (Routing Protocol)
   : 내부(RIP, OSPF), 외부(EGP, BGP)
- 장비
  - <b><span style='color:#006DD7'>Router</span></b>
   : 서로 다른 네트워크 호스트 간 패킷 전달에 최적 경로 지정
  - L3 Switch : 3계층에서 네트워크 단위 간 연결, IP레이어에서의 스위칭 → 외부로 전송 (경로제어, 고속 라우팅)

### 4 - 전송 계층 (Transport) : Segment

- 개념 : 종단 간 사용자들에게 <b><span style='color:#006DD7'>신뢰성 있는 데이터 전달</span></b> → 상위 계층들이 데이터 전달의 유효성, 효율성 생각하지 않도록
- 특징 : <b><span style='color:#006DD7'>순차번호</span></b> 기반 오류제어 방식, 종단 간 통신 다루는 최하위 계층
- 송신 : 세션 계층의 메시지 → <b><span style='color:#006DD7'>세그먼트로</span></b> 변환 → 네트워크 계층에 패킷으로 분할전송
- 프로토콜
  - <b><span style='color:#006DD7'>TCP</span></b> (Transmission Control)
   : 연결지향, 안정적, 순서대로, 에러없이 교환
  - <b><span style='color:#006DD7'>UDP</span></b> (User Diagram)
   : 비연결, 신뢰성X, 순서X
- 장비
  - L4 Switch : FTP, HTTP

### 5 - 세션 계층 (Session)

- 개념 : 프로세스들의 논리적 연결 담당 (TCP/IP 세션 연결 설정, 세션 메시지 전송) → <b><span style='color:#006DD7'>연결 끊기지 않도록 유지</span></b>
- 기능 : 통신을 위한 세션 확립, 유지, 중단 + 사용자 동기화, 오류 복구 명령 처리
- 프로토콜 
  - RPC (Remote Procedure Call)
   : 원격 프로시저 호출
  - NetBIOS (Network Basic I/O System)
   : 응용계층의 프로그램에게 API 제공 → 상호통신


### 6 - 표현 계층 (Presentation)

- 개념 : 응용계층 데이터 → 부호화, 변환 → <b><span style='color:#006DD7'>데이터 해석</span></b>
- 기능 : 압축, 암호화 → 데이터 효율, 보안 + 전송 포맷으로 변경
- 프로토콜 
  - JPEG : 이미지
  - MPEG : 멀티미디어 (비디오, 오디오)

### 7 - 응용 계층 (Application)

- 개념 : 여러 프로토콜 개체에 <b><span style='color:#006DD7'>사용자 인터페이스 제공</span></b>
- 기능 : 응용 프로세스 간 정보교환, 파일전송
- <b><span style='color:#006DD7'>프로토콜</span></b> 
  - HTTP (Hyper Text Transfer) : 하이퍼텍스트 기반
  - FTP (File Transfer) : TCP/IP 프로토콜로 파일 전송
  - SMTP (Simple Mail Transfer) : 인터넷에서 TCP 25로 이메일 보냄
  - POP3 (Post Office) : 원격 서버에서 TCP/IP 연결로 이메일 가져옴
  - IMAP (Internet Messaging AccesS) : 원격 서버에서 TCP/IP 연결로 이메일 가져옴
  - Telnet : 인터넷 or 로컬에서 네트워크 연결
  - SSH (Secure Shell) : Telnet의 보안버전 원격접속 (서로 연결된 컴퓨터 간)
  - SNMP (Simple Network Management) : TCP/IP 네트워크 관리 (네트워크 장치 정보 수집, 관리)
  - DNS
- 장비 
  - L7 Switch : 애플리케이션 정보 지능적으로 분석 → 트래픽 관리

<br><br>

# 📂 요구사항 확인

## 📝 요구사항 개발 프로세스 <b><span style='color:#2D3748; background-color:#fff5b1'>(도분명확)</span></b>

- 요구사항 **도출**
 : 문제이해 → 정보식별 → 수집방법 결정 → 수집된 요구사항 표현
  - 기법 : 인터뷰, 브레인스토밍, 델파이기법(전문가활용), 롤플레잉, 워크숍, 설문조사
<br>
- 요구사항 **분석**
 : 요구사항의 충돌/중복/누락 분석 → 완전성, 일관성 확보
  - 기법 : 자료흐름지향분석(DFD, 자료사전), 객체지향분석(UML)
    1. 요구사항 분류 : 기능적(기술/서비스) or 비기능적(제약사항)
    2. 개념모델링 : DFD, UML, ERD
    3. 요구사항 할당
    4. 요구사항 협상
    5. 정형분석 : 구문/의미 갖는 정형화된 언어 → 수학적 기호로 표현
<br>
- 요구사항 **명세**
 : 문서작성 → 산출물 : 요구사항 명세서
  - 기법 : 비정형 명세기법(자연어서술-FSM, State Chart), 정형 명세기법(수학적서술-VDM, Z Schema)
<br>
- 요구사항 **확인**/검증
 : 검토, 베이스라인 설정 → 요구사항 문서의 완전성, 일관성 검증
  - 기법 : <b><span style='color:#006DD7'>정형기술검토</span></b> (동료리뷰, 워크스루, 인스펙션(전문가))