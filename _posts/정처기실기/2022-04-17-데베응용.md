---
layout: single
title: "[정처기] 데이터베이스 응용"
categories: 
    - EIP
tags: 
    - [정처기, 정처기실기]
toc: true
toc_sticky: true
---

# <b>📂 집계형 SQL</b>


- 데이터 분석 함수 특성
  - 복수 행을 그룹별로 모아놓고 그룹당 단일 계산 결과 반환
  - GROUP BY 구문으로 복수 행 그룹핑

## <b>📝 집계함수 (Aggregate Function)</b>
 : 여러 행에서 하나의 결과값 반환 (NULL은 제외하고 계산)

> SELECT 칼럼1, 칼럼2, .., <b><span style='color:#006DD7'>집계함수</span></b>
> FROM 테이블
> WHERE 조건
> GROUP BY 칼럼1, 칼럼2, ..
> HAVING 조건식(집계함수 포함)

- GROUP BY
  - NULL값인 ROW는 제외
  - SELECT에서 사용하는 것과 같은 ALIAS 사용 불가
  - WHERE 구문 안에 포함X
  - WHERE이 먼저 실행 (대상 행을 우선 선별)
- HAVING
  - WHERE 구문에서 사용 불가한 집계함수 구문을 적용
  - 복수 행의 계산 결과를 조건별로 적용
  - GROUP BY 및 집계함수의 WHERE 구문
- 종류 : COUNT, SUM, AVG, MAX, MIN, STDDEV(표준편차), VARIAN(분산)

<br>

## <b>📝 그룹함수 (Group Function)</b>
 : 그룹별 결과 출력

- ROLLUP 함수
  - 지정 칼럼 수보다 하나 더 큰 레벨만큼 중간 집계 값 생성
  - 지정 칼럼은 계층별로 구성됨 → 순서 바뀌면 수행 결과도 바뀜

    > SELECT 칼럼1, 칼럼2, .., 집계함수
    > FROM 테이블
    > [ WHERE 조건 ]
    > GROUP BY [<b><span style='color:#006DD7'>집계 대상 아닌 칼럼</span></b>] <b><span style='color:#EF6F53'>ROLLUP</span></b> <b><span style='color:#006DD7'>(집계 대상 칼럼1, 2, ..)</span></b>
    > [ HAVING ]
    > [ ORDER BY ]

- CUBE 함수
  - 결합 가능한 모든 값에 다차원 집계 생성
  - 연산이 많아 시스템에 부담

    > SELECT 칼럼1, 칼럼2, .., 집계함수
    > FROM 테이블
    > [ WHERE 조건 ]
    > GROUP BY [칼럼1, 2, ..] <b><span style='color:#EF6F53'>CUBE</span></b> <b><span style='color:#006DD7'>(집계 대상 칼럼1, 2, ..)</span></b>
    > [ HAVING ]
    > [ ORDER BY ]

- GROUPING SETS 함수
  - 집계 대상 칼럼의 개별 집계
  - 칼럼 간 순서와 무관한 결과
  - ORDER BY로 집계 대상 글부과의 표시 순서 조정 가능

    > SELECT 칼럼1, 칼럼2, .., 집계함수
    > FROM 테이블
    > [ WHERE 조건 ]
    > GROUP BY [칼럼1, 2, ..] <b><span style='color:#EF6F53'>GROUPING SETS</span></b> <b><span style='color:#006DD7'>(집계 대상 칼럼1, 2, ..)</span></b>
    > [ HAVING ]
    > [ ORDER BY ]

<br>

## <b>📝 윈도함수 (Window Function)</b>
 : 데이터베이스를 사용한 온라인 분석 처리 용도의 함수

- OLAP 함수 (OnLine Analytical Processing)
 : 의사결정 지원 시스템. 같은 데이터를 여러 기준으로 분석하도록 도와줌

> SELECT 함수명(파라미터)
> <b><span style='color:#EF6F53'>OVER</span></b>
> 　( [ PARTITION BY 칼럼1, 2, .. ]
> 　　[ ORDER BY 칼럼A, B, .. ] )
> FROM 테이블

- 윈도 : PARTITION BY를 통해 구분된 레코드 집합
- 순위 함수
  - RANK, DENSE_RANK, ROW_NUMBER

> SELECT NAME, 
> 　　　　SALARY,
> 　　　　<b><span style='color:#006DD7'>RANK()</span></b> <b><span style='color:#EF6F53'>OVER</span></b> (<b><span style='color:#EF6F53'>ORDER BY</span></b> SALARY DESC) A,
> 　　　　<b><span style='color:#006DD7'>DENSE_RANK()</span></b> <b><span style='color:#EF6F53'>OVER</span></b> (<b><span style='color:#EF6F53'>ORDER BY</span></b> SALARY DESC) B,
> 　　　　<b><span style='color:#006DD7'>ROW_NUMBER()</span></b> <b><span style='color:#EF6F53'>OVER</span></b> (<b><span style='color:#EF6F53'>ORDER BY</span></b> SALARY DESC) C
> FROM EMPLOYEE;

<br><br>

# <b>📂 절차형 SQL</b>

- 출력부
 : 절차형 SQL이 정상적으로 구현되었는지 테스트

    > - DBMS_OUTPUT.PUT(문자열)
    : 개행 없이 문자열 출력
    > - DBMS_OUTPUT.PUT_LINE(문자열)
    : 개행 포함

- 제어부
  - 조건문
    - IF문
      > IF 조건 THEN 문장;
      > ELSEIF 조건 THEN 문장;
      > ELSE 문장;
      > END IF;
    - 간단한 케이스 문
      > CASE 변수
      > WHEN 값1 THEN SET 명령어;
      > WHEN 값2 THEN SET 명령어;
      > ELSE SET 명령어;
      > END CASE;
    - 검색된 케이스 문
      > CASE
      > WHEN 조건1 THEN SET 명령어;
      > WHEN 조건2 THEN SET 명령어;
      > ELSE SET 명령어;
      > END CASE;
  - 반복문
    - LOOP
      > LOOP 문장;
      > EXIT WHEN 탈출조건;
      > END LOOP;
    - WHILE
      > WHILE 반복조건 LOOP 문장;
      > EXIT WHEN 탈출조건
      > END LOOP;
    - FOR LOOP
      > FOR 인덱스 IN 시작값 .. 종료값
      > LOOP 문장;
      > END LOOP;
- 예외부
  > EXCEPTION
  > WHEN 조건 THEN 
  > SET 명령어;

<br>

## <b>📝 프로시저 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>디비컨 SET</span></b></b>
 : 쿼리 집합을 함수처럼 실행

> DECLARE : 프로시저 명칭, 변수, 인수, 데이터타입 정의
> BEGIN
> > CONTROL (조건문, 반복문)
> > SQL (DML)
> > EXCEPTION
> > TRANSCATION (실행부 → COMMIT, ROLLBACK)
>
> END

<br>

- 예시

        CREATE PROCEDURE SALES_CLOSING
            (V_CLOSING_dATE IN CHAR(80))
            IS 
            V_SALES_TOT_AMT NUMBER := 0;
        BEGIN
            DBMS_OUTPUT.PUT_LINE(V_CLOSING_DATE);
            # 제어부
                IF V_CLOSING_DATE < "20000101" THEN
                    SET V_CLOSING_DATE := "20201010";
                END IF;
            # SQL
                SELECT SUM(SALES_AMT)
                    INTO V_SALES_TOT_AMT    # 해당 변수에 저장
                FROM SALES_LIST_T
                WHERE SALES_DATE = V_CLOSING_DATE
            # 예외부
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                    SET V_SALES_TOT_AMT := 0;
            # 실행부
                DBMS_OUTPUT.PUT_LINE(V_SALES_TOT_AMT);
                COMMIT;
        END;

- 실행
        
        EXECUTE SALES_CLOSING('20170425')

<br>

## <b>📝 사용자 정의 함수</b>
 : SQL 수행 결과를 단일 값으로 <b><span style='color:#006DD7'>반환</span></b>



<br><br>

# <b>📂 데이터 조작 프로시저</b>