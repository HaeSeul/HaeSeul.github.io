---
layout: single
title: "[정처기] 프로그래밍 언어 활용"
categories: 
    - EIP
tags: 
    - [정처기, 정처기실기]
toc: true
toc_sticky: true
---

# <b>📂 기본 문법 활용하기</b>

## <b>📝 프로그래밍 기본 사항</b>

- 진수 (Antilogarithm) : 특정 개수의 숫자만 이용해 수를 나타내는 수 체계
- 아스키코드 (ASCII) : 미국 ANSI에서 표준화한 정보교환용 부호체계

    |10진수|부호|
    |:---:|:---:|
    |0|NULL|
    |32|' '(space)|
    |48|0|
    |49|1|
    |65|A|
    |97|a|

<br>

## <b>📝 데이터 타입</b>
 : 프로그래밍 언어에서 데이터를 식별하는 형태

|데이터타입|정의 | C언어 | Java |Python|
|:---|:---|:---:|:---:|:---:|
|불린 (Boolean)|조건의 참/거짓 판단||true, false|True, False|
|문자 (Character)|- 문자 하나를 저장<br>- 숫자로 메모리에 저장|&nbsp;char&nbsp;&nbsp;|char||
|문자열 타입 (String)|여러 문자 저장|char []| String||
|정수 타입 (Integer)|정수값 저장 | int | int ||
|부동 소수점 (Floating Point)| 소수점 포함하는 실수 저장 | float | double||

<br>

## <b>📝 변수</b>
 : 값을 주기억장치에 저장하기 위한 공간

- static 변수
  - 프로그램이 시작될 때 처음 한 번만 변수 초기화
  - 종료 전까지 메모리 유지
  - 함수에 의해 변수 선언 부분이 여러 번 호출되어도 초기화X

<br>

## <b>📝 배열</b>
 : 같은 타입의 변수들로 이루어진 집합

- 1차원 배열 선언
  - C언어
    - int a[5];
    - int[] a;
    - int a[5] = {1,2};
    - int[] a = {1,2};
  - Java
    - int []a = new int[3];
    - int a[] = new int[3];
    - int []a = {3,4};
- 2차원 배열 선언
  - C언어
    - int a[행][열];
    - int a[행][열] = {};
  - Java
    - int [][]a = new int[행][열];
    - int a[][] = new int[행][열];
    - int [][]a = \{\{1,2}, {3}, {4,5,6\}\};

<br>

## <b>📝 포인터</b>
 : 변수의 주소를 저장

```
int a = 10;
int* b = &a;            // a의 주소가 포인터 변수 b에 저장
printf("%d %d", a, *b)  // b가 기리키는(*) 값은 a이므로 a = *b
```

### <b>📌 1차원 배열과 1차원 포인터</b>

- <b><span style='color:#006DD7'>1차원 배열에서 배열명만 단독으로 사용하면 1차원 포인터와 동일</span></b>
- 값을 가리키는 경우
  - 배열명[요소]
  - *(배열명 + 요소)
  - 포인터[요소]
  - *(포인터 + 요소)
- 배열명 == &배열명[0] == 배열의 주소
- 배열명[0] == *배열명 == 배열의 0번지 값

```
int a[3] = {1,2};
int *p = a;
```

- a 단독으로 쓰면 포인터 → <b><span style='color:#006DD7'>*a</span></b>는 값
- a = p = &a[0]
 : 배열 a의 주소
- a[0] = p[0] = *a = *p
 : 배열 a의 0번지 값 (=1)
- (a+1) = (p+1) = &a[1]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소
- *(a+1) = *(p+1) = a[1]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소가 가리키는 값 (=2)

### <b>📌 2차원 배열과 1차원 포인터</b>

- <b><span style='color:#006DD7'>2차원 배열에서 배열명만 단독으로 사용하면 2차원 포인터와 동일</span></b>
- 값을 가리키는 경우
  - <b><span style='color:#67C71F'>*</span></b>배열명[요소]
  - <b><span style='color:#67C71F'>**</span></b>(배열명 + 요소)
  - <b><span style='color:#67C71F'>1차원포인터</span></b>[요소]
  - *(<b><span style='color:#67C71F'>1차원포인터</span></b> + 요소)

```
int a[3][2] = {1,2,3,4,5,6};
int *p = a[1];
```

- a 단독으로 쓰면 2차원 포인터
- a[] 형태로 쓰면 1차원 포인터 → <b><span style='color:#006DD7'>*a[]</span></b>는 값
- a[0] = &a[0][0]
 : 배열 a의 주소
- *a[0] = **a
 : 배열 a의 0번지의 값 (=1)
- *(a+1) = a[1] = &a[1][0]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소
- **(a+1) = *p = p[0]
 : a가 가리키는 값에서 1칸 떨어진 곳의 주소가 가리키는 값 (=2)
- *(p+1) = p[1] = a[1][1]
 : a[1]이 가리키는 &a[1][0]에서 1칸 뒤 값 (=4)

### <b>📌 2차원 배열과 포인터 배열</b>

```
int a[3][2] = {1,2,3,4,5,6};
int *p[3] = {a[2], a[0], a[1]};
```

- 배열 a의 2, 0, 1번지 주소(1차원 포인터)를 포인터배열 p에 저장
- a[2][0] = p[0][0] = *p[0] = 5

### <b>📌 2차원 배열과 2차원 포인터</b>

- <b><span style='color:#006DD7'>2차원 배열에서 배열명만 단독으로 사용하면 2차원 포인터와 동일</span></b>
- 값을 가리키는 경우
  - 배열명[요소][요소]
  - *배열명[요소]
  - **(배열명 + 요소)

```
int a[3][2] = {1,2,3,4,5,6};
int (*p)[2] = a;
int (*q)[2] = a+1;
```

- 2차원 배열 변수 p, q에 a 배열의 0, 1번지 주소를 2차원 포인터 변수에 저장
- a 단독으로 쓰면 2차원 포인터
- a[0][0] = p[0][0] = 1
- a[1][0] = p[1][0] = q[0][0] = 3

### <b>📌 1차원 배열과 문자열</b>

- <b><span style='color:#006DD7'>문자열을 초기화할 때 마지막에 NULL 문자 삽입됨</span></b>
- 배열 선언은 글자수보다 1 이상 큰 값으로
- 초기화 시 배열크기를 명시하지 않으면 문자열의 문자수+1 만큼 배열 자동 생성
- printf함수에서 %s로 문자열을 읽을 때 <b><span style='color:#006DD7'>시작 주소부터 NULL 직전값까지</span></b> 출력

```
char a[7] = "Hello";
printf("%s\n", a);      // Hello
printf("%s\n", a+1);    // ello
```

### <b>📌 2차원 배열과 문자열</b>

- 문자열을 여러 개 정의할 때 2차원 배열 사용

```
char a[2][8] = {"Hello", "Exciting"};
printf("%s\n", a[0]);   // Hello
printf("%s\n", a[1]);   // Exciting
a[0][4] = NULL
printf("%s\n", a[0]+2);   // ll
printf("%s\n", a[1]+3);   // iting
```

<br>

## <b>📝 자료형</b>

### <b>📌 자바 자료형</b>

1. **HashSet**
    - 중복된 원소를 허용하지 않는 집합(Set)의 성질을 가진 클래스 (순서 X, 자동정렬)
    - 선언
      - `Set 변수명 = new HashSet();`
      - `HashSet 변수명 = new HashSet();`
    - 메서드
      - `add(값)` : 값 추가, 중복허용 X
      - `remove(값)` : 값 삭제
      - `size()` : HashSet의 원소 개수
2. **ArrayList**
    - 크기가 가변적으로 변하는 선형리스트의 성질을 가진 클래스 (순서 O → 인덱스로 접근)
    - 선언
      - `List 변수명 = new ArrayList();`
      - `ArrayList 변수명 = new ArrayList();`
    - 메서드
      - `add(값)` : 값 추가
      - `add(인덱스, 값)` : 해당 인덱스에 값 추가
      - `remove(인덱스)` : 해당 인덱스의 값 제거
      - `get(인덱스)` : 해당 인덱스의 값 가져오기
      - `size()` : HashSet의 원소 개수
3. **LinkedList**
    - 데이터를 저장하는 노드가 전후 노드 상태를 알고 있는 자료구조 클래스
    - 선언
      - `Map 변수명 = new HashMap();`
      - `HashMap 변수명 = new HashMap();`
    - 메서드
      - `put(키, 값)` : 해당 키에 값 추가
      - `remove(키)` : 해당 키의 값 제거
      - `get(키)` : 해당 키의 값 가져오기
      - `size()` : HashMap의 원소 개수
4. **HashMap**
    - 키-값으로 구성된 객체를 저장하는 자료구조 클래스

### <b>📌 파이썬 자료형</b>

1. **세트형**
   - 중복을 허용하지 않는 집합 성질을 가지는 자료구조 (순서 X, 자동정렬)
   - 선언
     - `세트명 = set([요소1, 요소2, ...])`
     - `세트명 = {요소1, 요소2, ...}`
   - 메서드
     - `add(값)` : 값 1개 추가
     - `update([값1, 값2, ...])` : 여러 값을 한꺼번에 추가
     - `remove(값)` : 특정 값 제거
2. **리스트형**
   - 크기가 가변적으로 변하는 선형리스트 성질을 가지는 자료구조
   - 선언
     - `리스트명 = [요소1, 요소2, ...]`
   - 메서드
     - `append(값)` : 리스트 마지막에 값 추가
     - `insert(인덱스, 값)` : 인덱스 위치에 값 삽입
     - `remove(값)` : 해당 값 제거 (여러 개 있는 경우 맨 앞의 것 제거)
   - 인덱싱 (리스트에 n개의 값이 있을 때)
        |첫 번째|두 번째| ... |뒤에서 두 번째|마지막|
        |:---:|:---:|:---:|:---:|:---:|
        |0|1||(n-2)|(n-1)|
        |-n|-(n-1)||-2|-1|
   - 리스트 슬라이싱 : 여러 데이터에 동시에 접근하는 기법
     - `리스트명[시작인덱스 : 종료인덱스 : 스텝]` : 종료인덱스 전까지 슬라이싱
3. **튜플형**
   - 초기에 선언된 값에서 생성/삭제/수정이 불가능한 형태의 자료구조
   - 선언
     - `리스트명 = (요소1, 요소2, ...)`
   - 인덱싱 (튜플에 n개의 값이 있을 때)
        |첫 번째|두 번째| ... |뒤에서 두 번째|마지막|
        |:---:|:---:|:---:|:---:|:---:|
        |0|1||(n-2)|(n-1)|
        |-n|-(n-1)||-2|-1|
   - 튜플 슬라이싱
     -  `튜플명[시작인덱스 : 종료인덱스 : 스텝]` : 종료인덱스 전까지 슬라이싱
4. **딕셔너리형**
   - 키-값으로 구성된 객체를 저장하는 자료구조
   - 선언
     - `딕셔너리명 = {키1:값1, 키2:값2, ...}`
   - 요소 추가
     - `딕셔너리명[키] = 값`
   - 요소 삭제
     - `del 딕셔너리명[키]`

<br>

## <b>📝 식별자</b>
 : 프로그램 구성요소를 구분하기 위해 사용되는 이름

표기법
1. 카멜 표기법 (Camel Case)
 : 첫 단어만 소문자로 시작, 이어지는 단어는 대문자로 시작 ⇒ inputFunction
2. 파스칼 표기법 (Pascal Case)
 : 이어지는 여러 단어 모두 대문자로 시작 ⇒ InputFunction
3. 스네이크 표기법 (Snake Case)
 : 단어 사이 언더바 ⇒ input_function
4. 헝가리안 표기법 (Hungarian Case)
 : 두어에 자료형 붙이기 (int는 n, char은 c, 문자열은 sz) ⇒ nScore 정수형 식별자

<br>

## <b>📝 연산자</b>
 : 프로그램 실행을 위해 연산을 표기하는 기호

- 연산자 우선순위 ⇒ <b><span style='color:#2D3748; background-color:#fff5b1'>증산시 관비 논삼대</span></b>
  1. 증감 연산자 <b><span style='color:#67C71F'>⇒ 파이썬은 X</span></b>
  2. ! (논리), ~ (비트)
  3. 산술 연산자 (* / % + -)
  4. 시프트 연산자 (<< >>)
  5. 관계 연산자 (< <= > => == !=)
  6. 비트 연산자 (& ^ |)
  7. 논리 연산자 (&& ||)
  8. 삼항 연산자 ((조건식)?a:b)
  9. 대입 연산자 (= += -= *= /= %=)

* 비트 연산자
  - ~ (NOT) : 모든 비트 값 반대로 (=부호를 반대로 바꾼 값에 1을 뺀 값)
  - ^ (XOR) : 다르면 1, 같으면 0

* 대입 연산자
  - 파이썬 Swap 연산자
    ```python
    a, b = 10, 20
    print(a)  # 10
    print(b)  # 20
    a, b = b, a
    print(a)  # 20
    print(b)  # 10
    ```

<br>

## <b>📝 표준 함수</b>

### <b>📌 출력 함수</b>

- **C 언어**
  - 단순 출력 : `printf(문자열);`
  - 개행 : `printf("\n");`
  - 변수 출력 : `printf("포맷스트링", 변수명);`
    - `%c` : 문자 출력
    - `%s` : 문자열 출력
    - `%d` : 10진수 출력
    - `%[-][0][전체자릿수]d` : 10진수 출력
      - [-] : 왼쪽 정렬
      - [0] : 전체 자릿수에서 앞에 빈 공간만큼 0으로 채움
      - [전체자릿수] 만큼 공간 확보
    - `%x` : 16진수 출력
    - `%o` : 8진수 출력
    - `%f` : 소수 6자리 출력
    - `%[전체자릿수].[소수점자릿수]f` : 실수 출력
      - [전체자릿수] : 소수점 포함 자릿수

- **자바**
  - 단순 출력 : `System.out.print(문자열);` : 출력 후 개행X
  - 개행
    - `System.out.print("\n");` : ""안에 \n 만나면 개행
    - `System.out.println(문자열);` : 출력 후 개행
  - 변수 출력 : `System.out.printf("포맷스트링", 문자열);`

- **파이썬**
  - 단순 출력 및 개행
    - `print(문자열)` : 출력 후 개행
    - `print(문자열, end=' ')` : 출력 후 개행X
  - 변수 출력 : `print(변수명)`

### <b>📌 입력 함수</b>

- **C 언어**
  - 변수값 입력 : `scanf("포맷스트링", &변수명);
  - 문자열 입력 : `scanf("%s", 배열명); 

- **자바**
  - 정수형 입력
    - ```java
      Scanner scanner = new Scanner(System.in);
      i = scanner.nextInt();
      ```
  - 실수형 입력
    - ```java
      Scanner scanner = new Scanner(System.in);
      f = scanner.nextFloat();
      ```
  - 문자열 입력
    - ```java
      Scanner scanner = new Scanner(System.in);
      s = scanner.nextLine();
      ```

- **파이썬**
  - 문자열 입력
    - ```python
      s = input()
      ```
  - 숫자 입력
    - ```python
      s = input() # 문자열로 저장
      s = eval(s) # 숫자로 변환 (문자일 경우 에러)
      ```

## <b>📝 명령문</b>

### <b>📌 조건문</b>

- if 문
  - C, 자바
    - ```java
      if (조건문){
        명령문;
      } else if {
        명령문;
      } else {
        명령문;
      }
      ```
  - 파이썬
    - ```python
      if 조건문 :
        명령문
      elif 조건문 :
        명령문
      else :
        명령문
      ```

- switch 문 <b><span style='color:#67C71F'>⇒ 파이썬은 X</span></b>
  - C, 자바
    - ```java
      switch (식) {
        case 값:
          명령문;
          break;
        default:
          명령문;
      }
      ```

### <b>📌 반복문</b>

- while 문
  - C, 자바
    - ```java
      while (조건문) {
        명령문;
      }
      ```
  - 파이썬
    - ```python
      while 조건문 : 
        명령문
      ```

- do while 문 <b><span style='color:#67C71F'>⇒ 파이썬은 X</span></b>
  - C, 자바
    - ```java
      do {
        명령문;
      } while (조건문)
      ```

- 일반 for 문
  - C, 자바
    - ```java
      for (초기식; 조건식; 증감식) {
        명령문;
      }
      ```
  - 파이썬
    - ```python
      for 변수 in range(시작, 종료, 스텝) :
        # 종료값 이상이면 반복문 종료
        명령문
      ```

- for each 문
  - 자바
    - ```java
      for (제어변수 : 배열) {
        문장;
      }
      ```
  - 파이썬
    - ```python
      for 변수 in 리스트 :
        문장
      ```

<br>

## <b>📝 사용자 정의 자료형</b>
 : 사용자가 상황에 맞게 기존 자료형을 조합해 만드는 자료형

- 열거체
  - 서로 연관된 정수형 상수들의 집합
  - 멤버에 초깃값을 설정하지 않으면 0부터 차례로 할당
  - ```C
    #include <stdio.h>
    enum Week {
      Sunday,       // 0
      Monday,       // 1
      Tuesday = 5,
      Wednesday     // 6
    };
    void main() {
      enum Week week;
      week = Wednesday;
      printf("%d", week); // 6
    }
    ```

- 구조체 <b><span style='color:#67C71F'>⇒ 자바, 파이썬은 X</span></b>
  - 사용자가 기본 타입을 가지고 새롭게 정의
  - ```C
    struct Student{
      char gender;
      int age;
    }
    void main() {
      struct Student s;
      s.gender = 'F';
      s.age = 24;
    }
    ```

- 구조체와 포인터
  - 구조체에 일반 구조체 변수로 접근할 때는 .으로
  - 구조체에 구조체 포인터로 접근할 때는 ->로 접근
  - ```C
    void main() {
      struct Student s = {'F', 21};
      struct Student *p = &s;   // 포인터변수 p에 s 주소 저장

      // s에 포함된 변수값 출력
      printf("%c %d\n", s.gender, s.age);
      // s의 주소에 포함된 변수값들 출력
      printf("%c %d\n", (&s)->gender, (&s)->age);
      // p가 가리키는 구조체 값들 출력
      printf("%c %d\n", p->gender, p->age);
      // p가 가리키는 값(s 구조체들) 출력
      printf("%c %d\n", (*p).gender, (*p).age);
      // p는 1차원 포인터 → p[0]으로 s 구조체에 접근 가능
      printf("%c %d\n", p[0].gender, p[0].age);
    }
    ```

  - 1차원 구조체 배열과 1차원 구조체 포인터
    ```C
    void main() {
      struct Student s[3] = {'F', 21, 'M', 20, 'M', 24};
      struct Student *p = &s;   // 포인터변수 p에 s 주소 저장

      // s의 0번째에 있는 구조체 값 출력
      printf("%c %d\n", s[0].gender, s[0].age);
      // s가 가리키는 값(s의 0번째 구조체) 출력
      printf("%c %d\n", (*s).gender, (*s).age);
      // s는 배열이므로 단독으로 쓰면 1차원 구조체 포인터
      printf("%c %d\n", s->gender, s->age);
      // s의 1번째 있는 구조체의 값 출력
      printf("%c %d\n", (s+1)->gender, (s+1)->age);
    }
    ```
  
# <b>📂 언어 특성 활용하기</b>

## <b>📝 프로그래밍 언어별 분류</b>

- 개발 편의성에 따른 분류
  - 저급 언어 (기계어, 어셈블리어)
   : 기계가 이해할 수 있도록 만들어진 언어
  - 고급 언어 (C, C++, 자바, 파이썬)
   : 개발자가 소스 코드 작성 시 쉽게 이해

- 실행 방식에 따른 분류
  - 명령형 언어 (FORTRAN, COBOL, PASCAL, C)
   : 순차적으로 명령어 실행 ⇒ 절차형 언어
  - 객체 지향 언어 (JAVA, C++)
   : 객체 간 메시지 통신을 이용
  - 함수형 언어 (LISP)
   : 수식 등 함수로 프로그램 구성해 호출
  - 논리형 언어 (프롤로그) 
   : 논리 문장으로 프로그램 표현, 계산을 수행하는 개념에 기반

- 구현 기법에 따른 분류
  - 컴파일 방식의 언어 (FORTRAN, PASCAL, C, C++)
   : 고급 언어를 기계어로 번역, 컴파일러가 실행에 필요한 정보 미리 계산
  - 인터프리터 방식의 언어 (BASIC, 프롤로그, LISP)
   : 고급 언어 문장을 하나씩 번역/실행, 프로그램 실행과 동시에 동작
  - 혼합형 방식의 언어 (자바)
   : 고급 언어를 컴파일해 중간 언어로 변환 → 인터프리터가 번역

## <b>📝 프로그래밍 언어별 특성</b>

- 절차적 프로그래밍 언어
  - ALGOL
   : 알고리즘 연구개발 목적
  - C 언어
   : 유닉스 운영체제에서 사용
  - BASIC
   : 교육용, 쉬운 문법
  - FORTRAN
   : 과학 기술 전문 언어, 수학 함수 사용 가능

- 객체 지향 프로그래밍 언어
  - C++
   : C 문법에 객체 지향 개념과 일반화 프로그래밍을 위한 템플릿 기능 추가
  - C#
   : MS에서 개발, 불안전 코드 기술로 플랫폼 간 상호 운용성 확보
  - JAVA
   : 웹 애플리케이션 개발에 많이 사용, 자바 컴파일러가 변환
  - Delphi
   : 파스칼 문법에 기능 추가된 것, 윈도우 아래에서 모든 부분 프로그래밍 가능

- 스크립트 언어
  - PHP
   : 동적 웹 페이지 만들기 위함, 인터페이스 방식의 자체 인터프리터 제공
  - Perl
   : 인터프리터 방식, 실용성 굿, 강력한 문자열 처리 기능
  - Python
   : 다양한 플랫폼, 라이브러리, 언어 처리, 들여쓰기로 블록 구분
  - Javascript
   : 주로 웹 브라우저에서 사용, 다른 프로그램 내장 객체에도 접근 가능